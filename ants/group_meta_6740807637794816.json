{
    "assignment": {
        "active": false,
        "autograding_enabled": false,
        "course": {
            "active": true,
            "created": "2015-06-20 07:52:12.138670",
            "display_name": "CS 61A",
            "id": 5710200078073856,
            "institution": "UC Berkeley",
            "instructor": [],
            "offering": "cal/61A/su15"
        },
        "created": "2015-07-17 23:16:13.346110",
        "creator": {
            "created": "2015-02-02 17:10:40.000000",
            "email": [
                "greynotgray@berkeley.edu"
            ],
            "id": 6593334940270592,
            "is_admin": true
        },
        "display_name": "Project 3: Ants",
        "due_date": "2015-07-28 23:59:59.000000",
        "grading_script_file": "# run as bash, your zip will be extracted into the folder\n#layout: info.py grade.sh student_files extracted_zip_files\n# CHANGE these lines: \nmv lab01/* .;\npython3 ok --local --score;\n#Format: echo 'Score:\\n\\tTotal: 2.0\\nBlah\\nOk';\n# Please cleanup your files\nrm -rf ./*;",
        "id": 5876190422237184,
        "lock_date": "2015-08-14 23:59:59.000000",
        "max_group_size": 2,
        "name": "cal/cs61a/su15/proj3",
        "points": 23.0,
        "revision": false,
        "templates": "\"{'ants.py':  '\\\"\\\"\\\"The ants module implements game logic for Ants Vs. SomeBees.\\\"\\\"\\\"\\\\n\\\\nimport random\\\\nimport sys\\\\nfrom ucb import main, interact, trace\\\\nfrom collections import OrderedDict\\\\n\\\\n\\\\n################\\\\n# Core Classes #\\\\n################\\\\n\\\\nclass Place(object):\\\\n    \\\"\\\"\\\"A Place holds insects and has an exit to another Place.\\\"\\\"\\\"\\\\n\\\\n    def __init__(self, name, exit=None):\\\\n        \\\"\\\"\\\"Create a Place with the given exit.\\\\n\\\\n        name -- A string; the name of this Place.\\\\n        exit -- The Place reached by exiting this Place (may be None).\\\\n        \\\"\\\"\\\"\\\\n        self.name = name\\\\n        self.exit = exit\\\\n        self.bees = []        # A list of Bees\\\\n        self.ant = None       # An Ant\\\\n        self.entrance = None  # A Place\\\\n        # Phase 1: Add an entrance to the exit\\\\n        # BEGIN Problem 2\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 2\\\\n\\\\n    def add_insect(self, insect):\\\\n        \\\"\\\"\\\"Add an Insect to this Place.\\\\n\\\\n        There can be at most one Ant in a Place, unless exactly one of them is\\\\n        a BodyguardAnt (Phase 4), in which case there can be two. If add_insect\\\\n        tries to add more Ants than is allowed, an assertion error is raised.\\\\n\\\\n        There can be any number of Bees in a Place.\\\\n        \\\"\\\"\\\"\\\\n        if insect.is_ant:\\\\n            # Phase 4: Special handling for BodyguardAnt\\\\n            # BEGIN Problem 7\\\\n            \\\"*** REPLACE THIS LINE ***\\\"\\\\n            # END Problem 7\\\\n            assert self.ant is None, \\\\'Two ants in {0}\\\\'.format(self)\\\\n            self.ant = insect\\\\n        else:\\\\n            self.bees.append(insect)\\\\n        insect.place = self\\\\n\\\\n    def remove_insect(self, insect):\\\\n        \\\"\\\"\\\"Remove an Insect from this Place.\\\"\\\"\\\"\\\\n        if insect.is_ant:\\\\n            # Handle removal if insect is contained in self.ant\\\\n            assert self.ant is insect, \\\\'{0} is not in {1}\\\\'.format(insect, self)\\\\n            # Phase 4: Special handling for BodyguardAnt and QueenAnt\\\\n            # BEGIN Problem 7\\\\n            \\\"*** REPLACE THIS LINE ***\\\"\\\\n            self.ant = None\\\\n            # END Problem 7\\\\n        else:\\\\n            self.bees.remove(insect)\\\\n\\\\n        insect.place = None\\\\n\\\\n    def __str__(self):\\\\n        return self.name\\\\n\\\\n\\\\nclass Insect(object):\\\\n    \\\"\\\"\\\"An Insect, the base class of Ant and Bee, has armor and a Place.\\\"\\\"\\\"\\\\n\\\\n    is_ant = False\\\\n    damage = 0\\\\n\\\\n    def __init__(self, armor, place=None):\\\\n        \\\"\\\"\\\"Create an Insect with an armor amount and a starting Place.\\\"\\\"\\\"\\\\n        self.armor = armor\\\\n        self.place = place  # set by Place.add_insect and Place.remove_insect\\\\n\\\\n    def reduce_armor(self, amount):\\\\n        \\\"\\\"\\\"Reduce armor by amount, and remove the insect from its place if it\\\\n        has no armor remaining.\\\\n\\\\n        >>> test_insect = Insect(5)\\\\n        >>> test_insect.reduce_armor(2)\\\\n        >>> test_insect.armor\\\\n        3\\\\n        \\\"\\\"\\\"\\\\n        self.armor -= amount\\\\n        if self.armor <= 0:\\\\n            self.place.remove_insect(self)\\\\n\\\\n    def action(self, colony):\\\\n        \\\"\\\"\\\"The action performed each turn.\\\\n\\\\n        colony -- The AntColony, used to access game state information.\\\\n        \\\"\\\"\\\"\\\\n\\\\n    def __repr__(self):\\\\n        cname = type(self).__name__\\\\n        return \\\\'{0}({1}, {2})\\\\'.format(cname, self.armor, self.place)\\\\n\\\\n\\\\nclass Bee(Insect):\\\\n    \\\"\\\"\\\"A Bee moves from place to place, following exits and stinging ants.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Bee\\\\'\\\\n    damage = 1\\\\n\\\\n    def sting(self, ant):\\\\n        \\\"\\\"\\\"Attack an Ant, reducing the Ant\\\\'s armor by 1.\\\"\\\"\\\"\\\\n        ant.reduce_armor(self.damage)\\\\n\\\\n    def move_to(self, place):\\\\n        \\\"\\\"\\\"Move from the Bee\\\\'s current Place to a new Place.\\\"\\\"\\\"\\\\n        self.place.remove_insect(self)\\\\n        place.add_insect(self)\\\\n\\\\n    def blocked(self):\\\\n        \\\"\\\"\\\"Return True if this Bee cannot advance to the next Place.\\\"\\\"\\\"\\\\n        # Phase 3: Special handling for NinjaAnt\\\\n        # BEGIN Problem 6A\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        return self.place.ant is not None\\\\n        # END Problem 6A\\\\n\\\\n    def action(self, colony):\\\\n        \\\"\\\"\\\"A Bee\\\\'s action stings the Ant that blocks its exit if it is blocked,\\\\n        or moves to the exit of its current place otherwise.\\\\n\\\\n        colony -- The AntColony, used to access game state information.\\\\n        \\\"\\\"\\\"\\\\n        if self.blocked():\\\\n            self.sting(self.place.ant)\\\\n        elif self.armor > 0 and self.place.exit is not None:\\\\n            self.move_to(self.place.exit)\\\\n\\\\n\\\\nclass Ant(Insect):\\\\n    \\\"\\\"\\\"An Ant occupies a place and does work for the colony.\\\"\\\"\\\"\\\\n\\\\n    is_ant = True\\\\n    implemented = False  # Only implemented Ant classes should be instantiated\\\\n    food_cost = 0\\\\n\\\\n    def __init__(self, armor=1):\\\\n        \\\"\\\"\\\"Create an Ant with an armor quantity.\\\"\\\"\\\"\\\\n        Insect.__init__(self, armor)\\\\n\\\\n\\\\nclass HarvesterAnt(Ant):\\\\n    \\\"\\\"\\\"HarvesterAnt produces 1 additional food per turn for the colony.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Harvester\\\\'\\\\n    implemented = True\\\\n\\\\n    def action(self, colony):\\\\n        \\\"\\\"\\\"Produce 1 additional food for the colony.\\\\n\\\\n        colony -- The AntColony, used to access game state information.\\\\n        \\\"\\\"\\\"\\\\n        # BEGIN Problem 1\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 1\\\\n\\\\n\\\\nclass ThrowerAnt(Ant):\\\\n    \\\"\\\"\\\"ThrowerAnt throws a leaf each turn at the nearest Bee in its range.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Thrower\\\\'\\\\n    implemented = True\\\\n    damage = 1\\\\n\\\\n    def nearest_bee(self, hive):\\\\n        \\\"\\\"\\\"Return the nearest Bee in a Place that is not the Hive, connected to\\\\n        the ThrowerAnt\\\\'s Place by following entrances.\\\\n\\\\n        This method returns None if there is no such Bee (or none in range).\\\\n        \\\"\\\"\\\"\\\\n        # BEGIN Problem 3B\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        return random_or_none(self.place.bees)\\\\n        # END Problem 3B\\\\n\\\\n    def throw_at(self, target):\\\\n        \\\"\\\"\\\"Throw a leaf at the target Bee, reducing its armor.\\\"\\\"\\\"\\\\n        if target is not None:\\\\n            target.reduce_armor(self.damage)\\\\n\\\\n    def action(self, colony):\\\\n        \\\"\\\"\\\"Throw a leaf at the nearest Bee in range.\\\"\\\"\\\"\\\\n        self.throw_at(self.nearest_bee(colony.hive))\\\\n\\\\n        \\\\ndef random_or_none(s):\\\\n    \\\"\\\"\\\"Return a random element of sequence s, or return None if s is empty.\\\"\\\"\\\"\\\\n    if s:\\\\n        return random.choice(s)\\\\n\\\\n\\\\n##############\\\\n# Extensions #\\\\n##############\\\\n\\\\nclass Water(Place):\\\\n    \\\"\\\"\\\"Water is a place that can only hold \\\\'watersafe\\\\' insects.\\\"\\\"\\\"\\\\n\\\\n    def add_insect(self, insect):\\\\n        \\\"\\\"\\\"Add insect if it is watersafe, otherwise reduce its armor to 0.\\\"\\\"\\\"\\\\n        # BEGIN Problem 3A\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 3A\\\\n\\\\n\\\\nclass FireAnt(Ant):\\\\n    \\\"\\\"\\\"FireAnt cooks any Bee in its Place when it expires.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Fire\\\\'\\\\n    damage = 3\\\\n    # BEGIN Problem 4A\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\n    # END Problem 4A\\\\n\\\\n    def reduce_armor(self, amount):\\\\n        # BEGIN Problem 4A\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 4A\\\\n\\\\n\\\\nclass LongThrower(ThrowerAnt):\\\\n    \\\"\\\"\\\"A ThrowerAnt that only throws leaves at Bees at least 5 places away.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Long\\\\'\\\\n    # BEGIN Problem 4B\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\n    # END Problem 4B\\\\n\\\\n\\\\nclass ShortThrower(ThrowerAnt):\\\\n    \\\"\\\"\\\"A ThrowerAnt that only throws leaves at Bees at most 3 places away.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Short\\\\'\\\\n    # BEGIN Problem 4B\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\n    # END Problem 4B\\\\n\\\\n\\\\n# BEGIN Problem 5A\\\\n\\\"*** REPLACE THIS LINE ***\\\"\\\\n# The WallAnt class\\\\n# END Problem 5A\\\\n\\\\n\\\\nclass NinjaAnt(Ant):\\\\n    \\\"\\\"\\\"NinjaAnt does not block the path and damages all bees in its place.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Ninja\\\\'\\\\n    damage = 1\\\\n    # BEGIN Problem 6A\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\n    # END Problem 6A\\\\n\\\\n    def action(self, colony):\\\\n        # BEGIN Problem 6A\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 6A\\\\n\\\\n\\\\n# BEGIN Problem 5B\\\\n\\\"*** REPLACE THIS LINE ***\\\"\\\\n# The ScubaThrower class\\\\n# END Problem 5B\\\\n\\\\n\\\\nclass HungryAnt(Ant):\\\\n    \\\"\\\"\\\"HungryAnt will take three turns to digest a Bee in its place.\\\\n    While digesting, the HungryAnt can\\\\'t eat another Bee.\\\\n    \\\"\\\"\\\"\\\\n    name = \\\\'Hungry\\\\'\\\\n    # BEGIN Problem 6B\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\n    # END Problem 6B\\\\n\\\\n    def __init__(self):\\\\n        # BEGIN Problem 6B\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 6B\\\\n\\\\n    def eat_bee(self, bee):\\\\n        # BEGIN Problem 6B\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 6B\\\\n\\\\n    def action(self, colony):\\\\n        # BEGIN Problem 6B\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 6B\\\\n\\\\n\\\\nclass BodyguardAnt(Ant):\\\\n    \\\"\\\"\\\"BodyguardAnt provides protection to other Ants.\\\"\\\"\\\"\\\\n    name = \\\\'Bodyguard\\\\'\\\\n    # BEGIN Problem 7\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\n    # END Problem 7\\\\n\\\\n    def __init__(self):\\\\n        Ant.__init__(self, 2)\\\\n        self.ant = None  # The Ant hidden in this bodyguard\\\\n\\\\n    def contain_ant(self, ant):\\\\n        # BEGIN Problem 7\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 7\\\\n\\\\n    def action(self, colony):\\\\n        # BEGIN Problem 7\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 7\\\\n\\\\nclass TankAnt(BodyguardAnt):\\\\n    \\\"\\\"\\\"TankAnt provides both offensive and defensive capabilities.\\\"\\\"\\\"\\\\n    name = \\\\'Tank\\\\'\\\\n    # BEGIN Problem 8\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\n    # END Problem 8\\\\n\\\\n    def action(self, colony):\\\\n        # BEGIN Problem 8\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 8\\\\n\\\\n\\\\nclass QueenPlace(object):\\\\n    \\\"\\\"\\\"A place that represents both places in which the bees find the queen.\\\\n\\\\n    (1) The original colony queen location at the end of all tunnels, and\\\\n    (2) The place in which the QueenAnt resides.\\\\n    \\\"\\\"\\\"\\\\n    def __init__(self, colony_queen, ant_queen):\\\\n        # BEGIN Problem 9\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 9\\\\n\\\\n    @property\\\\n    def bees(self):\\\\n        # BEGIN Problem 9\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 9\\\\n\\\\n\\\\nclass QueenAnt(Ant):  # You should change this line\\\\n    \\\"\\\"\\\"The Queen of the colony.  The game is over if a bee enters her place.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Queen\\\\'\\\\n    # BEGIN Problem 9\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\n    # END Problem 9\\\\n\\\\n    def __init__(self):\\\\n        # BEGIN Problem 9\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 9\\\\n\\\\n    def action(self, colony):\\\\n        \\\"\\\"\\\"A queen ant throws a leaf, but also doubles the damage of ants\\\\n        in her tunnel.\\\\n\\\\n        Impostor queens do only one thing: reduce their own armor to 0.\\\\n        \\\"\\\"\\\"\\\\n        # BEGIN Problem 9\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 9\\\\n\\\\n\\\\nclass AntRemover(Ant):\\\\n    \\\"\\\"\\\"Allows the player to remove ants from the board in the GUI.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Remover\\\\'\\\\n    implemented = False\\\\n\\\\n    def __init__(self):\\\\n        Ant.__init__(self, 0)\\\\n\\\\n\\\\n##################\\\\n# Status Effects #\\\\n##################\\\\n\\\\ndef make_slow(action):\\\\n    \\\"\\\"\\\"Return a new action method that calls action every other turn.\\\\n\\\\n    action -- An action method of some Bee\\\\n    \\\"\\\"\\\"\\\\n    # BEGIN Problem EC\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    # END Problem EC\\\\n\\\\ndef make_stun(action):\\\\n    \\\"\\\"\\\"Return a new action method that does nothing.\\\\n\\\\n    action -- An action method of some Bee\\\\n    \\\"\\\"\\\"\\\\n    # BEGIN Problem EC\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    # END Problem EC\\\\n\\\\ndef apply_effect(effect, bee, duration):\\\\n    \\\"\\\"\\\"Apply a status effect to a Bee that lasts for duration turns.\\\"\\\"\\\"\\\\n    # BEGIN Problem EC\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    # END Problem EC\\\\n\\\\n\\\\nclass SlowThrower(ThrowerAnt):\\\\n    \\\"\\\"\\\"ThrowerAnt that causes Slow on Bees.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Slow\\\\'\\\\n    # BEGIN Problem EC\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\n    # END Problem EC\\\\n\\\\n    def throw_at(self, target):\\\\n        if target:\\\\n            apply_effect(make_slow, target, 3)\\\\n\\\\n\\\\nclass StunThrower(ThrowerAnt):\\\\n    \\\"\\\"\\\"ThrowerAnt that causes Stun on Bees.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Stun\\\\'\\\\n    # BEGIN Problem EC\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\n    # END Problem EC\\\\n\\\\n    def throw_at(self, target):\\\\n        if target:\\\\n            apply_effect(make_stun, target, 1)\\\\n\\\\n\\\\n##################\\\\n# Bees Extension #\\\\n##################\\\\n\\\\nclass Wasp(Bee):\\\\n    \\\"\\\"\\\"Class of Bee that has higher damage.\\\"\\\"\\\"\\\\n    name = \\\\'Wasp\\\\'\\\\n    damage = 2\\\\n\\\\nclass Hornet(Bee):\\\\n    \\\"\\\"\\\"Class of bee that is capable of taking two actions per turn, although\\\\n    its overall damage output is lower. Immune to status effects.\\\\n    \\\"\\\"\\\"\\\\n    name = \\\\'Hornet\\\\'\\\\n    damage = 0.25\\\\n\\\\n    def action(self, colony):\\\\n        for i in range(2):\\\\n            if self.armor > 0:\\\\n                super().action(colony)\\\\n\\\\n    def __setattr__(self, name, value):\\\\n        if name != \\\\'action\\\\':\\\\n            object.__setattr__(self, name, value)\\\\n\\\\nclass NinjaBee(Bee):\\\\n    \\\"\\\"\\\"A Bee that cannot be blocked. Is capable of moving past all defenses to\\\\n    assassinate the Queen.\\\\n    \\\"\\\"\\\"\\\\n    name = \\\\'NinjaBee\\\\'\\\\n\\\\n    def blocked(self):\\\\n        return False\\\\n            \\\\nclass Boss(Wasp, Hornet):\\\\n    \\\"\\\"\\\"The leader of the bees. Combines the high damage of the Wasp along with\\\\n    status effect immunity of Hornets. Damage to the boss is capped up to 8\\\\n    damage by a single attack.\\\\n    \\\"\\\"\\\"\\\\n    name = \\\\'Boss\\\\'\\\\n    damage_cap = 8\\\\n    action = Wasp.action\\\\n\\\\n    def reduce_armor(self, amount):\\\\n        super().reduce_armor(self.damage_modifier(amount))\\\\n\\\\n    def damage_modifier(self, amount):\\\\n        return amount * self.damage_cap/(self.damage_cap + amount)\\\\n\\\\nclass Hive(Place):\\\\n    \\\"\\\"\\\"The Place from which the Bees launch their assault.\\\\n\\\\n    assault_plan -- An AssaultPlan; when & where bees enter the colony.\\\\n    \\\"\\\"\\\"\\\\n\\\\n    def __init__(self, assault_plan):\\\\n        self.name = \\\\'Hive\\\\'\\\\n        self.assault_plan = assault_plan\\\\n        self.bees = []\\\\n        for bee in assault_plan.all_bees:\\\\n            self.add_insect(bee)\\\\n        # The following attributes are always None for a Hive\\\\n        self.entrance = None\\\\n        self.ant = None\\\\n        self.exit = None\\\\n\\\\n    def strategy(self, colony):\\\\n        exits = [p for p in colony.places.values() if p.entrance is self]\\\\n        for bee in self.assault_plan.get(colony.time, []):\\\\n            bee.move_to(random.choice(exits))\\\\n            colony.active_bees.append(bee)\\\\n\\\\n\\\\nclass AntColony(object):\\\\n    \\\"\\\"\\\"An ant collective that manages global game state and simulates time.\\\\n\\\\n    Attributes:\\\\n    time -- elapsed time\\\\n    food -- the colony\\\\'s available food total\\\\n    queen -- the place where the queen resides\\\\n    places -- A list of all places in the colony (including a Hive)\\\\n    bee_entrances -- A list of places that bees can enter\\\\n    \\\"\\\"\\\"\\\\n\\\\n    def __init__(self, strategy, hive, ant_types, create_places, dimensions, food=2):\\\\n        \\\"\\\"\\\"Create an AntColony for simulating a game.\\\\n\\\\n        Arguments:\\\\n        strategy -- a function to deploy ants to places\\\\n        hive -- a Hive full of bees\\\\n        ant_types -- a list of ant constructors\\\\n        create_places -- a function that creates the set of places\\\\n        dimensions -- a pair containing the dimensions of the game layout\\\\n        \\\"\\\"\\\"\\\\n        self.time = 0\\\\n        self.food = food\\\\n        self.strategy = strategy\\\\n        self.hive = hive\\\\n        self.ant_types = OrderedDict((a.name, a) for a in ant_types)\\\\n        self.dimensions = dimensions\\\\n        self.active_bees = []\\\\n        self.configure(hive, create_places)\\\\n\\\\n    def configure(self, hive, create_places):\\\\n        \\\"\\\"\\\"Configure the places in the colony.\\\"\\\"\\\"\\\\n        self.queen = Place(\\\\'AntQueen\\\\')\\\\n        self.places = OrderedDict()\\\\n        self.bee_entrances = []\\\\n        def register_place(place, is_bee_entrance):\\\\n            self.places[place.name] = place\\\\n            if is_bee_entrance:\\\\n                place.entrance = hive\\\\n                self.bee_entrances.append(place)\\\\n        register_place(self.hive, False)\\\\n        create_places(self.queen, register_place, self.dimensions[0], self.dimensions[1])\\\\n\\\\n    def simulate(self):\\\\n        \\\"\\\"\\\"Simulate an attack on the ant colony (i.e., play the game).\\\"\\\"\\\"\\\\n        num_bees = len(self.bees)\\\\n        while len(self.queen.bees) == 0 and num_bees > 0:\\\\n            self.hive.strategy(self)            # Bees invade\\\\n            self.strategy(self)                 # Ants deploy\\\\n            for ant in self.ants:               # Ants take actions\\\\n                if ant.armor > 0:\\\\n                    ant.action(self)\\\\n            for bee in self.active_bees[:]:     # Bees take actions\\\\n                if bee.armor > 0:\\\\n                    bee.action(self)\\\\n                if bee.armor <= 0:\\\\n                    num_bees -= 1\\\\n                    self.active_bees.remove(bee)\\\\n            self.time += 1\\\\n        if len(self.queen.bees) > 0:\\\\n            print(\\\\'The ant queen has perished. Please try again.\\\\')\\\\n            return False\\\\n        else:\\\\n            print(\\\\'All bees are vanquished. You win!\\\\')\\\\n            return True\\\\n\\\\n    def deploy_ant(self, place_name, ant_type_name):\\\\n        \\\"\\\"\\\"Place an ant if enough food is available.\\\\n\\\\n        This method is called by the current strategy to deploy ants.\\\\n        \\\"\\\"\\\"\\\\n        constructor = self.ant_types[ant_type_name]\\\\n        if self.food < constructor.food_cost:\\\\n            print(\\\\'Not enough food remains to place \\\\' + ant_type_name)\\\\n        else:\\\\n            ant = constructor()\\\\n            self.places[place_name].add_insect(ant)\\\\n            self.food -= constructor.food_cost\\\\n            return ant\\\\n\\\\n    def remove_ant(self, place_name):\\\\n        \\\"\\\"\\\"Remove an Ant from the Colony.\\\"\\\"\\\"\\\\n        place = self.places[place_name]\\\\n        if place.ant is not None:\\\\n            place.remove_insect(place.ant)\\\\n\\\\n    @property\\\\n    def ants(self):\\\\n        return [p.ant for p in self.places.values() if p.ant is not None]\\\\n\\\\n    @property\\\\n    def bees(self):\\\\n        return [b for p in self.places.values() for b in p.bees]\\\\n\\\\n    @property\\\\n    def insects(self):\\\\n        return self.ants + self.bees\\\\n\\\\n    def __str__(self):\\\\n        status = \\\\' (Food: {0}, Time: {1})\\\\'.format(self.food, self.time)\\\\n        return str([str(i) for i in self.ants + self.bees]) + status\\\\n\\\\n\\\\ndef ant_types():\\\\n    \\\"\\\"\\\"Return a list of all implemented Ant classes.\\\"\\\"\\\"\\\\n    all_ant_types = []\\\\n    new_types = [Ant]\\\\n    while new_types:\\\\n        new_types = [t for c in new_types for t in c.__subclasses__()]\\\\n        all_ant_types.extend(new_types)\\\\n    return [t for t in all_ant_types if t.implemented]\\\\n\\\\ndef interactive_strategy(colony):\\\\n    \\\"\\\"\\\"A strategy that starts an interactive session and lets the user make\\\\n    changes to the colony.\\\\n\\\\n    For example, one might deploy a ThrowerAnt to the first tunnel by invoking\\\\n    colony.deploy_ant(\\\\'tunnel_0_0\\\\', \\\\'Thrower\\\\')\\\\n    \\\"\\\"\\\"\\\\n    print(\\\\'colony: \\\\' + str(colony))\\\\n    msg = \\\\'<Control>-D (<Control>-Z <Enter> on Windows) completes a turn.\\\\\\\\n\\\\'\\\\n    interact(msg)\\\\n\\\\ndef start_with_strategy(args, strategy):\\\\n    \\\"\\\"\\\"Reads command-line arguments and starts a game with those options.\\\"\\\"\\\"\\\\n    import argparse\\\\n    parser = argparse.ArgumentParser(description=\\\"Play Ants vs. SomeBees\\\")\\\\n    parser.add_argument(\\\\'-d\\\\', type=str, metavar=\\\\'DIFFICULTY\\\\',\\\\n                        help=\\\\'sets difficulty of game (easy/medium/hard/insane)\\\\')\\\\n    parser.add_argument(\\\\'-w\\\\', \\\\'--water\\\\', action=\\\\'store_true\\\\',\\\\n                        help=\\\\'loads a full layout with water\\\\')\\\\n    parser.add_argument(\\\\'--food\\\\', type=int,\\\\n                        help=\\\\'number of food to start with when testing\\\\', default=2)\\\\n    args = parser.parse_args()\\\\n\\\\n    assault_plan = make_test_assault_plan()\\\\n    layout = dry_layout\\\\n    tunnel_length = 9\\\\n    num_tunnels = 1\\\\n    food = args.food\\\\n\\\\n    if args.water:\\\\n        layout = wet_layout\\\\n    if args.d in [\\\\'e\\\\', \\\\'easy\\\\']:\\\\n        assault_plan = make_easy_assault_plan()\\\\n        num_tunnels = 2\\\\n        food = 2\\\\n    elif args.d in [\\\\'n\\\\', \\\\'normal\\\\']:\\\\n        assault_plan = make_normal_assault_plan()\\\\n        num_tunnels = 3\\\\n        food = 2\\\\n    elif args.d in [\\\\'h\\\\', \\\\'hard\\\\']:\\\\n        assault_plan = make_hard_assault_plan()\\\\n        num_tunnels = 4\\\\n        food = 2\\\\n    elif args.d in [\\\\'i\\\\', \\\\'insane\\\\']:\\\\n        assault_plan = make_insane_assault_plan()\\\\n        num_tunnels = 4\\\\n        food = 2\\\\n\\\\n    hive = Hive(assault_plan)\\\\n    dimensions = (num_tunnels, tunnel_length)\\\\n    return AntColony(strategy, hive, ant_types(), layout, dimensions, food).simulate()\\\\n\\\\n\\\\n###########\\\\n# Layouts #\\\\n###########\\\\n\\\\ndef wet_layout(queen, register_place, tunnels=3, length=9, moat_frequency=3):\\\\n    \\\"\\\"\\\"Register a mix of wet and and dry places.\\\"\\\"\\\"\\\\n    for tunnel in range(tunnels):\\\\n        exit = queen\\\\n        for step in range(length):\\\\n            if moat_frequency != 0 and (step + 1) % moat_frequency == 0:\\\\n                exit = Water(\\\\'water_{0}_{1}\\\\'.format(tunnel, step), exit)\\\\n            else:\\\\n                exit = Place(\\\\'tunnel_{0}_{1}\\\\'.format(tunnel, step), exit)\\\\n            register_place(exit, step == length - 1)\\\\n\\\\ndef dry_layout(queen, register_place, tunnels=3, length=9):\\\\n    \\\"\\\"\\\"Register dry tunnels.\\\"\\\"\\\"\\\\n    wet_layout(queen, register_place, tunnels, length, 0)\\\\n\\\\n\\\\n#################\\\\n# Assault Plans #\\\\n#################\\\\n\\\\nclass AssaultPlan(dict):\\\\n    \\\"\\\"\\\"The Bees\\\\' plan of attack for the Colony.  Attacks come in timed waves.\\\\n\\\\n    An AssaultPlan is a dictionary from times (int) to waves (list of Bees).\\\\n\\\\n    >>> AssaultPlan().add_wave(4, 2)\\\\n    {4: [Bee(3, None), Bee(3, None)]}\\\\n    \\\"\\\"\\\"\\\\n\\\\n    def add_wave(self, bee_type, bee_armor, time, count):\\\\n        \\\"\\\"\\\"Add a wave at time with count Bees that have the specified armor.\\\"\\\"\\\"\\\\n        bees = [bee_type(bee_armor) for _ in range(count)]\\\\n        self.setdefault(time, []).extend(bees)\\\\n        return self\\\\n\\\\n    @property\\\\n    def all_bees(self):\\\\n        \\\"\\\"\\\"Place all Bees in the hive and return the list of Bees.\\\"\\\"\\\"\\\\n        return [bee for wave in self.values() for bee in wave]\\\\n\\\\ndef make_test_assault_plan():\\\\n    return AssaultPlan().add_wave(Bee, 3, 2, 1).add_wave(Bee, 3, 3, 1)\\\\n\\\\ndef make_easy_assault_plan():\\\\n    plan = AssaultPlan()\\\\n    for time in range(3, 16, 2):\\\\n        plan.add_wave(Bee, 3, time, 1)\\\\n    plan.add_wave(Wasp, 3, 4, 1)\\\\n    plan.add_wave(NinjaBee, 3, 8, 1)\\\\n    plan.add_wave(Hornet, 3, 12, 1)\\\\n    plan.add_wave(Boss, 15, 16, 1)\\\\n    return plan\\\\n\\\\ndef make_normal_assault_plan():\\\\n    plan = AssaultPlan()\\\\n    for time in range(3, 16, 2):\\\\n        plan.add_wave(Bee, 3, time, 2)\\\\n    plan.add_wave(Wasp, 3, 4, 1)\\\\n    plan.add_wave(NinjaBee, 3, 8, 1)\\\\n    plan.add_wave(Hornet, 3, 12, 1)\\\\n    plan.add_wave(Wasp, 3, 16, 1)\\\\n    \\\\n    #Boss Stage\\\\n    for time in range(21, 30, 2):\\\\n        plan.add_wave(Bee, 3, time, 2)\\\\n    plan.add_wave(Wasp, 3, 22, 2)\\\\n    plan.add_wave(Hornet, 3, 24, 2)\\\\n    plan.add_wave(NinjaBee, 3, 26, 2)\\\\n    plan.add_wave(Hornet, 3, 28, 2)\\\\n    plan.add_wave(Boss, 20, 30, 1)\\\\n    return plan\\\\n\\\\ndef make_hard_assault_plan():\\\\n    plan = AssaultPlan()\\\\n    for time in range(3, 16, 2):\\\\n        plan.add_wave(Bee, 4, time, 2)\\\\n    plan.add_wave(Hornet, 4, 4, 2)\\\\n    plan.add_wave(Wasp, 4, 8, 2)\\\\n    plan.add_wave(NinjaBee, 4, 12, 2)\\\\n    plan.add_wave(Wasp, 4, 16, 2)\\\\n    \\\\n    #Boss Stage\\\\n    for time in range(21, 30, 2):\\\\n        plan.add_wave(Bee, 4, time, 3)\\\\n    plan.add_wave(Wasp, 4, 22, 2)\\\\n    plan.add_wave(Hornet, 4, 24, 2)\\\\n    plan.add_wave(NinjaBee, 4, 26, 2)\\\\n    plan.add_wave(Hornet, 4, 28, 2)\\\\n    plan.add_wave(Boss, 30, 30, 1)\\\\n    return plan\\\\n\\\\ndef make_insane_assault_plan():\\\\n    plan = AssaultPlan()\\\\n    plan.add_wave(Hornet, 5, 2, 2)\\\\n    for time in range(3, 16, 2):\\\\n        plan.add_wave(Bee, 5, time, 2)\\\\n    plan.add_wave(Hornet, 5, 4, 2)\\\\n    plan.add_wave(Wasp, 5, 8, 2)\\\\n    plan.add_wave(NinjaBee, 5, 12, 2)\\\\n    plan.add_wave(Wasp, 5, 16, 2)\\\\n    \\\\n    #Boss Stage\\\\n    for time in range(21, 30, 2):\\\\n        plan.add_wave(Bee, 5, time, 3)\\\\n    plan.add_wave(Wasp, 5, 22, 2)\\\\n    plan.add_wave(Hornet, 5, 24, 2)\\\\n    plan.add_wave(NinjaBee, 5, 26, 2)\\\\n    plan.add_wave(Hornet, 5, 28, 2)\\\\n    plan.add_wave(Boss, 30, 30, 2)\\\\n    return plan\\\\n\\\\n\\\\nfrom utils import *\\\\n@main\\\\ndef run(*args):\\\\n    Insect.reduce_armor = class_method_wrapper(Insect.reduce_armor,\\\\n            pre=print_expired_insects)\\\\n    start_with_strategy(args, interactive_strategy)\\\\n'}\"",
        "url": "http://www.cs61a.org/proj/ants",
        "zip_file_url": null
    },
    "created": "2015-07-18 20:14:36.481730",
    "id": 6740807637794816,
    "invited": [],
    "member": [
        {
            "created": "2015-06-21 20:11:09.502840",
            "email": [
                "binglinsong@berkeley.edu"
            ],
            "id": 6682339753066496,
            "is_admin": false
        },
        {
            "created": "2015-06-21 20:10:43.895930",
            "email": [
                "anthony0312@berkeley.edu"
            ],
            "id": 5285489686872064,
            "is_admin": false
        }
    ],
    "order": null
}