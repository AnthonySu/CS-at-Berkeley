{
    "assignment": {
        "active": false,
        "autograding_enabled": false,
        "course": {
            "active": true,
            "created": "2015-06-20 07:52:12.138670",
            "display_name": "CS 61A",
            "id": 5710200078073856,
            "institution": "UC Berkeley",
            "instructor": [],
            "offering": "cal/61A/su15"
        },
        "created": "2015-07-17 23:16:13.346110",
        "creator": {
            "created": "2015-02-02 17:10:40.000000",
            "email": [
                "greynotgray@berkeley.edu"
            ],
            "id": 6593334940270592,
            "is_admin": true
        },
        "display_name": "Project 3: Ants",
        "due_date": "2015-07-28 23:59:59.000000",
        "grading_script_file": "# run as bash, your zip will be extracted into the folder\n#layout: info.py grade.sh student_files extracted_zip_files\n# CHANGE these lines: \nmv lab01/* .;\npython3 ok --local --score;\n#Format: echo 'Score:\\n\\tTotal: 2.0\\nBlah\\nOk';\n# Please cleanup your files\nrm -rf ./*;",
        "id": 5876190422237184,
        "lock_date": "2015-08-14 23:59:59.000000",
        "max_group_size": 2,
        "name": "cal/cs61a/su15/proj3",
        "points": 23.0,
        "revision": false,
        "templates": "\"{'ants.py':  '\\\"\\\"\\\"The ants module implements game logic for Ants Vs. SomeBees.\\\"\\\"\\\"\\\\n\\\\nimport random\\\\nimport sys\\\\nfrom ucb import main, interact, trace\\\\nfrom collections import OrderedDict\\\\n\\\\n\\\\n################\\\\n# Core Classes #\\\\n################\\\\n\\\\nclass Place(object):\\\\n    \\\"\\\"\\\"A Place holds insects and has an exit to another Place.\\\"\\\"\\\"\\\\n\\\\n    def __init__(self, name, exit=None):\\\\n        \\\"\\\"\\\"Create a Place with the given exit.\\\\n\\\\n        name -- A string; the name of this Place.\\\\n        exit -- The Place reached by exiting this Place (may be None).\\\\n        \\\"\\\"\\\"\\\\n        self.name = name\\\\n        self.exit = exit\\\\n        self.bees = []        # A list of Bees\\\\n        self.ant = None       # An Ant\\\\n        self.entrance = None  # A Place\\\\n        # Phase 1: Add an entrance to the exit\\\\n        # BEGIN Problem 2\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 2\\\\n\\\\n    def add_insect(self, insect):\\\\n        \\\"\\\"\\\"Add an Insect to this Place.\\\\n\\\\n        There can be at most one Ant in a Place, unless exactly one of them is\\\\n        a BodyguardAnt (Phase 4), in which case there can be two. If add_insect\\\\n        tries to add more Ants than is allowed, an assertion error is raised.\\\\n\\\\n        There can be any number of Bees in a Place.\\\\n        \\\"\\\"\\\"\\\\n        if insect.is_ant:\\\\n            # Phase 4: Special handling for BodyguardAnt\\\\n            # BEGIN Problem 7\\\\n            \\\"*** REPLACE THIS LINE ***\\\"\\\\n            # END Problem 7\\\\n            assert self.ant is None, \\\\'Two ants in {0}\\\\'.format(self)\\\\n            self.ant = insect\\\\n        else:\\\\n            self.bees.append(insect)\\\\n        insect.place = self\\\\n\\\\n    def remove_insect(self, insect):\\\\n        \\\"\\\"\\\"Remove an Insect from this Place.\\\"\\\"\\\"\\\\n        if insect.is_ant:\\\\n            # Handle removal if insect is contained in self.ant\\\\n            assert self.ant is insect, \\\\'{0} is not in {1}\\\\'.format(insect, self)\\\\n            # Phase 4: Special handling for BodyguardAnt and QueenAnt\\\\n            # BEGIN Problem 7\\\\n            \\\"*** REPLACE THIS LINE ***\\\"\\\\n            self.ant = None\\\\n            # END Problem 7\\\\n        else:\\\\n            self.bees.remove(insect)\\\\n\\\\n        insect.place = None\\\\n\\\\n    def __str__(self):\\\\n        return self.name\\\\n\\\\n\\\\nclass Insect(object):\\\\n    \\\"\\\"\\\"An Insect, the base class of Ant and Bee, has armor and a Place.\\\"\\\"\\\"\\\\n\\\\n    is_ant = False\\\\n    damage = 0\\\\n\\\\n    def __init__(self, armor, place=None):\\\\n        \\\"\\\"\\\"Create an Insect with an armor amount and a starting Place.\\\"\\\"\\\"\\\\n        self.armor = armor\\\\n        self.place = place  # set by Place.add_insect and Place.remove_insect\\\\n\\\\n    def reduce_armor(self, amount):\\\\n        \\\"\\\"\\\"Reduce armor by amount, and remove the insect from its place if it\\\\n        has no armor remaining.\\\\n\\\\n        >>> test_insect = Insect(5)\\\\n        >>> test_insect.reduce_armor(2)\\\\n        >>> test_insect.armor\\\\n        3\\\\n        \\\"\\\"\\\"\\\\n        self.armor -= amount\\\\n        if self.armor <= 0:\\\\n            self.place.remove_insect(self)\\\\n\\\\n    def action(self, colony):\\\\n        \\\"\\\"\\\"The action performed each turn.\\\\n\\\\n        colony -- The AntColony, used to access game state information.\\\\n        \\\"\\\"\\\"\\\\n\\\\n    def __repr__(self):\\\\n        cname = type(self).__name__\\\\n        return \\\\'{0}({1}, {2})\\\\'.format(cname, self.armor, self.place)\\\\n\\\\n\\\\nclass Bee(Insect):\\\\n    \\\"\\\"\\\"A Bee moves from place to place, following exits and stinging ants.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Bee\\\\'\\\\n    damage = 1\\\\n\\\\n    def sting(self, ant):\\\\n        \\\"\\\"\\\"Attack an Ant, reducing the Ant\\\\'s armor by 1.\\\"\\\"\\\"\\\\n        ant.reduce_armor(self.damage)\\\\n\\\\n    def move_to(self, place):\\\\n        \\\"\\\"\\\"Move from the Bee\\\\'s current Place to a new Place.\\\"\\\"\\\"\\\\n        self.place.remove_insect(self)\\\\n        place.add_insect(self)\\\\n\\\\n    def blocked(self):\\\\n        \\\"\\\"\\\"Return True if this Bee cannot advance to the next Place.\\\"\\\"\\\"\\\\n        # Phase 3: Special handling for NinjaAnt\\\\n        # BEGIN Problem 6A\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        return self.place.ant is not None\\\\n        # END Problem 6A\\\\n\\\\n    def action(self, colony):\\\\n        \\\"\\\"\\\"A Bee\\\\'s action stings the Ant that blocks its exit if it is blocked,\\\\n        or moves to the exit of its current place otherwise.\\\\n\\\\n        colony -- The AntColony, used to access game state information.\\\\n        \\\"\\\"\\\"\\\\n        if self.blocked():\\\\n            self.sting(self.place.ant)\\\\n        elif self.armor > 0 and self.place.exit is not None:\\\\n            self.move_to(self.place.exit)\\\\n\\\\n\\\\nclass Ant(Insect):\\\\n    \\\"\\\"\\\"An Ant occupies a place and does work for the colony.\\\"\\\"\\\"\\\\n\\\\n    is_ant = True\\\\n    implemented = False  # Only implemented Ant classes should be instantiated\\\\n    food_cost = 0\\\\n\\\\n    def __init__(self, armor=1):\\\\n        \\\"\\\"\\\"Create an Ant with an armor quantity.\\\"\\\"\\\"\\\\n        Insect.__init__(self, armor)\\\\n\\\\n\\\\nclass HarvesterAnt(Ant):\\\\n    \\\"\\\"\\\"HarvesterAnt produces 1 additional food per turn for the colony.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Harvester\\\\'\\\\n    implemented = True\\\\n\\\\n    def action(self, colony):\\\\n        \\\"\\\"\\\"Produce 1 additional food for the colony.\\\\n\\\\n        colony -- The AntColony, used to access game state information.\\\\n        \\\"\\\"\\\"\\\\n        # BEGIN Problem 1\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 1\\\\n\\\\n\\\\nclass ThrowerAnt(Ant):\\\\n    \\\"\\\"\\\"ThrowerAnt throws a leaf each turn at the nearest Bee in its range.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Thrower\\\\'\\\\n    implemented = True\\\\n    damage = 1\\\\n\\\\n    def nearest_bee(self, hive):\\\\n        \\\"\\\"\\\"Return the nearest Bee in a Place that is not the Hive, connected to\\\\n        the ThrowerAnt\\\\'s Place by following entrances.\\\\n\\\\n        This method returns None if there is no such Bee (or none in range).\\\\n        \\\"\\\"\\\"\\\\n        # BEGIN Problem 3B\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        return random_or_none(self.place.bees)\\\\n        # END Problem 3B\\\\n\\\\n    def throw_at(self, target):\\\\n        \\\"\\\"\\\"Throw a leaf at the target Bee, reducing its armor.\\\"\\\"\\\"\\\\n        if target is not None:\\\\n            target.reduce_armor(self.damage)\\\\n\\\\n    def action(self, colony):\\\\n        \\\"\\\"\\\"Throw a leaf at the nearest Bee in range.\\\"\\\"\\\"\\\\n        self.throw_at(self.nearest_bee(colony.hive))\\\\n\\\\n        \\\\ndef random_or_none(s):\\\\n    \\\"\\\"\\\"Return a random element of sequence s, or return None if s is empty.\\\"\\\"\\\"\\\\n    if s:\\\\n        return random.choice(s)\\\\n\\\\n\\\\n##############\\\\n# Extensions #\\\\n##############\\\\n\\\\nclass Water(Place):\\\\n    \\\"\\\"\\\"Water is a place that can only hold \\\\'watersafe\\\\' insects.\\\"\\\"\\\"\\\\n\\\\n    def add_insect(self, insect):\\\\n        \\\"\\\"\\\"Add insect if it is watersafe, otherwise reduce its armor to 0.\\\"\\\"\\\"\\\\n        # BEGIN Problem 3A\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 3A\\\\n\\\\n\\\\nclass FireAnt(Ant):\\\\n    \\\"\\\"\\\"FireAnt cooks any Bee in its Place when it expires.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Fire\\\\'\\\\n    damage = 3\\\\n    # BEGIN Problem 4A\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\n    # END Problem 4A\\\\n\\\\n    def reduce_armor(self, amount):\\\\n        # BEGIN Problem 4A\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 4A\\\\n\\\\n\\\\nclass LongThrower(ThrowerAnt):\\\\n    \\\"\\\"\\\"A ThrowerAnt that only throws leaves at Bees at least 5 places away.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Long\\\\'\\\\n    # BEGIN Problem 4B\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\n    # END Problem 4B\\\\n\\\\n\\\\nclass ShortThrower(ThrowerAnt):\\\\n    \\\"\\\"\\\"A ThrowerAnt that only throws leaves at Bees at most 3 places away.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Short\\\\'\\\\n    # BEGIN Problem 4B\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\n    # END Problem 4B\\\\n\\\\n\\\\n# BEGIN Problem 5A\\\\n\\\"*** REPLACE THIS LINE ***\\\"\\\\n# The WallAnt class\\\\n# END Problem 5A\\\\n\\\\n\\\\nclass NinjaAnt(Ant):\\\\n    \\\"\\\"\\\"NinjaAnt does not block the path and damages all bees in its place.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Ninja\\\\'\\\\n    damage = 1\\\\n    # BEGIN Problem 6A\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\n    # END Problem 6A\\\\n\\\\n    def action(self, colony):\\\\n        # BEGIN Problem 6A\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 6A\\\\n\\\\n\\\\n# BEGIN Problem 5B\\\\n\\\"*** REPLACE THIS LINE ***\\\"\\\\n# The ScubaThrower class\\\\n# END Problem 5B\\\\n\\\\n\\\\nclass HungryAnt(Ant):\\\\n    \\\"\\\"\\\"HungryAnt will take three turns to digest a Bee in its place.\\\\n    While digesting, the HungryAnt can\\\\'t eat another Bee.\\\\n    \\\"\\\"\\\"\\\\n    name = \\\\'Hungry\\\\'\\\\n    # BEGIN Problem 6B\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\n    # END Problem 6B\\\\n\\\\n    def __init__(self):\\\\n        # BEGIN Problem 6B\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 6B\\\\n\\\\n    def eat_bee(self, bee):\\\\n        # BEGIN Problem 6B\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 6B\\\\n\\\\n    def action(self, colony):\\\\n        # BEGIN Problem 6B\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 6B\\\\n\\\\n\\\\nclass BodyguardAnt(Ant):\\\\n    \\\"\\\"\\\"BodyguardAnt provides protection to other Ants.\\\"\\\"\\\"\\\\n    name = \\\\'Bodyguard\\\\'\\\\n    # BEGIN Problem 7\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\n    # END Problem 7\\\\n\\\\n    def __init__(self):\\\\n        Ant.__init__(self, 2)\\\\n        self.ant = None  # The Ant hidden in this bodyguard\\\\n\\\\n    def contain_ant(self, ant):\\\\n        # BEGIN Problem 7\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 7\\\\n\\\\n    def action(self, colony):\\\\n        # BEGIN Problem 7\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 7\\\\n\\\\nclass TankAnt(BodyguardAnt):\\\\n    \\\"\\\"\\\"TankAnt provides both offensive and defensive capabilities.\\\"\\\"\\\"\\\\n    name = \\\\'Tank\\\\'\\\\n    # BEGIN Problem 8\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\n    # END Problem 8\\\\n\\\\n    def action(self, colony):\\\\n        # BEGIN Problem 8\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 8\\\\n\\\\n\\\\nclass QueenPlace(object):\\\\n    \\\"\\\"\\\"A place that represents both places in which the bees find the queen.\\\\n\\\\n    (1) The original colony queen location at the end of all tunnels, and\\\\n    (2) The place in which the QueenAnt resides.\\\\n    \\\"\\\"\\\"\\\\n    def __init__(self, colony_queen, ant_queen):\\\\n        # BEGIN Problem 9\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 9\\\\n\\\\n    @property\\\\n    def bees(self):\\\\n        # BEGIN Problem 9\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 9\\\\n\\\\n\\\\nclass QueenAnt(Ant):  # You should change this line\\\\n    \\\"\\\"\\\"The Queen of the colony.  The game is over if a bee enters her place.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Queen\\\\'\\\\n    # BEGIN Problem 9\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\n    # END Problem 9\\\\n\\\\n    def __init__(self):\\\\n        # BEGIN Problem 9\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 9\\\\n\\\\n    def action(self, colony):\\\\n        \\\"\\\"\\\"A queen ant throws a leaf, but also doubles the damage of ants\\\\n        in her tunnel.\\\\n\\\\n        Impostor queens do only one thing: reduce their own armor to 0.\\\\n        \\\"\\\"\\\"\\\\n        # BEGIN Problem 9\\\\n        \\\"*** REPLACE THIS LINE ***\\\"\\\\n        # END Problem 9\\\\n\\\\n\\\\nclass AntRemover(Ant):\\\\n    \\\"\\\"\\\"Allows the player to remove ants from the board in the GUI.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Remover\\\\'\\\\n    implemented = False\\\\n\\\\n    def __init__(self):\\\\n        Ant.__init__(self, 0)\\\\n\\\\n\\\\n##################\\\\n# Status Effects #\\\\n##################\\\\n\\\\ndef make_slow(action):\\\\n    \\\"\\\"\\\"Return a new action method that calls action every other turn.\\\\n\\\\n    action -- An action method of some Bee\\\\n    \\\"\\\"\\\"\\\\n    # BEGIN Problem EC\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    # END Problem EC\\\\n\\\\ndef make_stun(action):\\\\n    \\\"\\\"\\\"Return a new action method that does nothing.\\\\n\\\\n    action -- An action method of some Bee\\\\n    \\\"\\\"\\\"\\\\n    # BEGIN Problem EC\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    # END Problem EC\\\\n\\\\ndef apply_effect(effect, bee, duration):\\\\n    \\\"\\\"\\\"Apply a status effect to a Bee that lasts for duration turns.\\\"\\\"\\\"\\\\n    # BEGIN Problem EC\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    # END Problem EC\\\\n\\\\n\\\\nclass SlowThrower(ThrowerAnt):\\\\n    \\\"\\\"\\\"ThrowerAnt that causes Slow on Bees.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Slow\\\\'\\\\n    # BEGIN Problem EC\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\n    # END Problem EC\\\\n\\\\n    def throw_at(self, target):\\\\n        if target:\\\\n            apply_effect(make_slow, target, 3)\\\\n\\\\n\\\\nclass StunThrower(ThrowerAnt):\\\\n    \\\"\\\"\\\"ThrowerAnt that causes Stun on Bees.\\\"\\\"\\\"\\\\n\\\\n    name = \\\\'Stun\\\\'\\\\n    # BEGIN Problem EC\\\\n    \\\"*** REPLACE THIS LINE ***\\\"\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\n    # END Problem EC\\\\n\\\\n    def throw_at(self, target):\\\\n        if target:\\\\n            apply_effect(make_stun, target, 1)\\\\n\\\\n\\\\n##################\\\\n# Bees Extension #\\\\n##################\\\\n\\\\nclass Wasp(Bee):\\\\n    \\\"\\\"\\\"Class of Bee that has higher damage.\\\"\\\"\\\"\\\\n    name = \\\\'Wasp\\\\'\\\\n    damage = 2\\\\n\\\\nclass Hornet(Bee):\\\\n    \\\"\\\"\\\"Class of bee that is capable of taking two actions per turn, although\\\\n    its overall damage output is lower. Immune to status effects.\\\\n    \\\"\\\"\\\"\\\\n    name = \\\\'Hornet\\\\'\\\\n    damage = 0.25\\\\n\\\\n    def action(self, colony):\\\\n        for i in range(2):\\\\n            if self.armor > 0:\\\\n                super().action(colony)\\\\n\\\\n    def __setattr__(self, name, value):\\\\n        if name != \\\\'action\\\\':\\\\n            object.__setattr__(self, name, value)\\\\n\\\\nclass NinjaBee(Bee):\\\\n    \\\"\\\"\\\"A Bee that cannot be blocked. Is capable of moving past all defenses to\\\\n    assassinate the Queen.\\\\n    \\\"\\\"\\\"\\\\n    name = \\\\'NinjaBee\\\\'\\\\n\\\\n    def blocked(self):\\\\n        return False\\\\n            \\\\nclass Boss(Wasp, Hornet):\\\\n    \\\"\\\"\\\"The leader of the bees. Combines the high damage of the Wasp along with\\\\n    status effect immunity of Hornets. Damage to the boss is capped up to 8\\\\n    damage by a single attack.\\\\n    \\\"\\\"\\\"\\\\n    name = \\\\'Boss\\\\'\\\\n    damage_cap = 8\\\\n    action = Wasp.action\\\\n\\\\n    def reduce_armor(self, amount):\\\\n        super().reduce_armor(self.damage_modifier(amount))\\\\n\\\\n    def damage_modifier(self, amount):\\\\n        return amount * self.damage_cap/(self.damage_cap + amount)\\\\n\\\\nclass Hive(Place):\\\\n    \\\"\\\"\\\"The Place from which the Bees launch their assault.\\\\n\\\\n    assault_plan -- An AssaultPlan; when & where bees enter the colony.\\\\n    \\\"\\\"\\\"\\\\n\\\\n    def __init__(self, assault_plan):\\\\n        self.name = \\\\'Hive\\\\'\\\\n        self.assault_plan = assault_plan\\\\n        self.bees = []\\\\n        for bee in assault_plan.all_bees:\\\\n            self.add_insect(bee)\\\\n        # The following attributes are always None for a Hive\\\\n        self.entrance = None\\\\n        self.ant = None\\\\n        self.exit = None\\\\n\\\\n    def strategy(self, colony):\\\\n        exits = [p for p in colony.places.values() if p.entrance is self]\\\\n        for bee in self.assault_plan.get(colony.time, []):\\\\n            bee.move_to(random.choice(exits))\\\\n            colony.active_bees.append(bee)\\\\n\\\\n\\\\nclass AntColony(object):\\\\n    \\\"\\\"\\\"An ant collective that manages global game state and simulates time.\\\\n\\\\n    Attributes:\\\\n    time -- elapsed time\\\\n    food -- the colony\\\\'s available food total\\\\n    queen -- the place where the queen resides\\\\n    places -- A list of all places in the colony (including a Hive)\\\\n    bee_entrances -- A list of places that bees can enter\\\\n    \\\"\\\"\\\"\\\\n\\\\n    def __init__(self, strategy, hive, ant_types, create_places, dimensions, food=2):\\\\n        \\\"\\\"\\\"Create an AntColony for simulating a game.\\\\n\\\\n        Arguments:\\\\n        strategy -- a function to deploy ants to places\\\\n        hive -- a Hive full of bees\\\\n        ant_types -- a list of ant constructors\\\\n        create_places -- a function that creates the set of places\\\\n        dimensions -- a pair containing the dimensions of the game layout\\\\n        \\\"\\\"\\\"\\\\n        self.time = 0\\\\n        self.food = food\\\\n        self.strategy = strategy\\\\n        self.hive = hive\\\\n        self.ant_types = OrderedDict((a.name, a) for a in ant_types)\\\\n        self.dimensions = dimensions\\\\n        self.active_bees = []\\\\n        self.configure(hive, create_places)\\\\n\\\\n    def configure(self, hive, create_places):\\\\n        \\\"\\\"\\\"Configure the places in the colony.\\\"\\\"\\\"\\\\n        self.queen = Place(\\\\'AntQueen\\\\')\\\\n        self.places = OrderedDict()\\\\n        self.bee_entrances = []\\\\n        def register_place(place, is_bee_entrance):\\\\n            self.places[place.name] = place\\\\n            if is_bee_entrance:\\\\n                place.entrance = hive\\\\n                self.bee_entrances.append(place)\\\\n        register_place(self.hive, False)\\\\n        create_places(self.queen, register_place, self.dimensions[0], self.dimensions[1])\\\\n\\\\n    def simulate(self):\\\\n        \\\"\\\"\\\"Simulate an attack on the ant colony (i.e., play the game).\\\"\\\"\\\"\\\\n        num_bees = len(self.bees)\\\\n        while len(self.queen.bees) == 0 and num_bees > 0:\\\\n            self.hive.strategy(self)            # Bees invade\\\\n            self.strategy(self)                 # Ants deploy\\\\n            for ant in self.ants:               # Ants take actions\\\\n                if ant.armor > 0:\\\\n                    ant.action(self)\\\\n            for bee in self.active_bees[:]:     # Bees take actions\\\\n                if bee.armor > 0:\\\\n                    bee.action(self)\\\\n                if bee.armor <= 0:\\\\n                    num_bees -= 1\\\\n                    self.active_bees.remove(bee)\\\\n            self.time += 1\\\\n        if len(self.queen.bees) > 0:\\\\n            print(\\\\'The ant queen has perished. Please try again.\\\\')\\\\n            return False\\\\n        else:\\\\n            print(\\\\'All bees are vanquished. You win!\\\\')\\\\n            return True\\\\n\\\\n    def deploy_ant(self, place_name, ant_type_name):\\\\n        \\\"\\\"\\\"Place an ant if enough food is available.\\\\n\\\\n        This method is called by the current strategy to deploy ants.\\\\n        \\\"\\\"\\\"\\\\n        constructor = self.ant_types[ant_type_name]\\\\n        if self.food < constructor.food_cost:\\\\n            print(\\\\'Not enough food remains to place \\\\' + ant_type_name)\\\\n        else:\\\\n            ant = constructor()\\\\n            self.places[place_name].add_insect(ant)\\\\n            self.food -= constructor.food_cost\\\\n            return ant\\\\n\\\\n    def remove_ant(self, place_name):\\\\n        \\\"\\\"\\\"Remove an Ant from the Colony.\\\"\\\"\\\"\\\\n        place = self.places[place_name]\\\\n        if place.ant is not None:\\\\n            place.remove_insect(place.ant)\\\\n\\\\n    @property\\\\n    def ants(self):\\\\n        return [p.ant for p in self.places.values() if p.ant is not None]\\\\n\\\\n    @property\\\\n    def bees(self):\\\\n        return [b for p in self.places.values() for b in p.bees]\\\\n\\\\n    @property\\\\n    def insects(self):\\\\n        return self.ants + self.bees\\\\n\\\\n    def __str__(self):\\\\n        status = \\\\' (Food: {0}, Time: {1})\\\\'.format(self.food, self.time)\\\\n        return str([str(i) for i in self.ants + self.bees]) + status\\\\n\\\\n\\\\ndef ant_types():\\\\n    \\\"\\\"\\\"Return a list of all implemented Ant classes.\\\"\\\"\\\"\\\\n    all_ant_types = []\\\\n    new_types = [Ant]\\\\n    while new_types:\\\\n        new_types = [t for c in new_types for t in c.__subclasses__()]\\\\n        all_ant_types.extend(new_types)\\\\n    return [t for t in all_ant_types if t.implemented]\\\\n\\\\ndef interactive_strategy(colony):\\\\n    \\\"\\\"\\\"A strategy that starts an interactive session and lets the user make\\\\n    changes to the colony.\\\\n\\\\n    For example, one might deploy a ThrowerAnt to the first tunnel by invoking\\\\n    colony.deploy_ant(\\\\'tunnel_0_0\\\\', \\\\'Thrower\\\\')\\\\n    \\\"\\\"\\\"\\\\n    print(\\\\'colony: \\\\' + str(colony))\\\\n    msg = \\\\'<Control>-D (<Control>-Z <Enter> on Windows) completes a turn.\\\\\\\\n\\\\'\\\\n    interact(msg)\\\\n\\\\ndef start_with_strategy(args, strategy):\\\\n    \\\"\\\"\\\"Reads command-line arguments and starts a game with those options.\\\"\\\"\\\"\\\\n    import argparse\\\\n    parser = argparse.ArgumentParser(description=\\\"Play Ants vs. SomeBees\\\")\\\\n    parser.add_argument(\\\\'-d\\\\', type=str, metavar=\\\\'DIFFICULTY\\\\',\\\\n                        help=\\\\'sets difficulty of game (easy/medium/hard/insane)\\\\')\\\\n    parser.add_argument(\\\\'-w\\\\', \\\\'--water\\\\', action=\\\\'store_true\\\\',\\\\n                        help=\\\\'loads a full layout with water\\\\')\\\\n    parser.add_argument(\\\\'--food\\\\', type=int,\\\\n                        help=\\\\'number of food to start with when testing\\\\', default=2)\\\\n    args = parser.parse_args()\\\\n\\\\n    assault_plan = make_test_assault_plan()\\\\n    layout = dry_layout\\\\n    tunnel_length = 9\\\\n    num_tunnels = 1\\\\n    food = args.food\\\\n\\\\n    if args.water:\\\\n        layout = wet_layout\\\\n    if args.d in [\\\\'e\\\\', \\\\'easy\\\\']:\\\\n        assault_plan = make_easy_assault_plan()\\\\n        num_tunnels = 2\\\\n        food = 2\\\\n    elif args.d in [\\\\'n\\\\', \\\\'normal\\\\']:\\\\n        assault_plan = make_normal_assault_plan()\\\\n        num_tunnels = 3\\\\n        food = 2\\\\n    elif args.d in [\\\\'h\\\\', \\\\'hard\\\\']:\\\\n        assault_plan = make_hard_assault_plan()\\\\n        num_tunnels = 4\\\\n        food = 2\\\\n    elif args.d in [\\\\'i\\\\', \\\\'insane\\\\']:\\\\n        assault_plan = make_insane_assault_plan()\\\\n        num_tunnels = 4\\\\n        food = 2\\\\n\\\\n    hive = Hive(assault_plan)\\\\n    dimensions = (num_tunnels, tunnel_length)\\\\n    return AntColony(strategy, hive, ant_types(), layout, dimensions, food).simulate()\\\\n\\\\n\\\\n###########\\\\n# Layouts #\\\\n###########\\\\n\\\\ndef wet_layout(queen, register_place, tunnels=3, length=9, moat_frequency=3):\\\\n    \\\"\\\"\\\"Register a mix of wet and and dry places.\\\"\\\"\\\"\\\\n    for tunnel in range(tunnels):\\\\n        exit = queen\\\\n        for step in range(length):\\\\n            if moat_frequency != 0 and (step + 1) % moat_frequency == 0:\\\\n                exit = Water(\\\\'water_{0}_{1}\\\\'.format(tunnel, step), exit)\\\\n            else:\\\\n                exit = Place(\\\\'tunnel_{0}_{1}\\\\'.format(tunnel, step), exit)\\\\n            register_place(exit, step == length - 1)\\\\n\\\\ndef dry_layout(queen, register_place, tunnels=3, length=9):\\\\n    \\\"\\\"\\\"Register dry tunnels.\\\"\\\"\\\"\\\\n    wet_layout(queen, register_place, tunnels, length, 0)\\\\n\\\\n\\\\n#################\\\\n# Assault Plans #\\\\n#################\\\\n\\\\nclass AssaultPlan(dict):\\\\n    \\\"\\\"\\\"The Bees\\\\' plan of attack for the Colony.  Attacks come in timed waves.\\\\n\\\\n    An AssaultPlan is a dictionary from times (int) to waves (list of Bees).\\\\n\\\\n    >>> AssaultPlan().add_wave(4, 2)\\\\n    {4: [Bee(3, None), Bee(3, None)]}\\\\n    \\\"\\\"\\\"\\\\n\\\\n    def add_wave(self, bee_type, bee_armor, time, count):\\\\n        \\\"\\\"\\\"Add a wave at time with count Bees that have the specified armor.\\\"\\\"\\\"\\\\n        bees = [bee_type(bee_armor) for _ in range(count)]\\\\n        self.setdefault(time, []).extend(bees)\\\\n        return self\\\\n\\\\n    @property\\\\n    def all_bees(self):\\\\n        \\\"\\\"\\\"Place all Bees in the hive and return the list of Bees.\\\"\\\"\\\"\\\\n        return [bee for wave in self.values() for bee in wave]\\\\n\\\\ndef make_test_assault_plan():\\\\n    return AssaultPlan().add_wave(Bee, 3, 2, 1).add_wave(Bee, 3, 3, 1)\\\\n\\\\ndef make_easy_assault_plan():\\\\n    plan = AssaultPlan()\\\\n    for time in range(3, 16, 2):\\\\n        plan.add_wave(Bee, 3, time, 1)\\\\n    plan.add_wave(Wasp, 3, 4, 1)\\\\n    plan.add_wave(NinjaBee, 3, 8, 1)\\\\n    plan.add_wave(Hornet, 3, 12, 1)\\\\n    plan.add_wave(Boss, 15, 16, 1)\\\\n    return plan\\\\n\\\\ndef make_normal_assault_plan():\\\\n    plan = AssaultPlan()\\\\n    for time in range(3, 16, 2):\\\\n        plan.add_wave(Bee, 3, time, 2)\\\\n    plan.add_wave(Wasp, 3, 4, 1)\\\\n    plan.add_wave(NinjaBee, 3, 8, 1)\\\\n    plan.add_wave(Hornet, 3, 12, 1)\\\\n    plan.add_wave(Wasp, 3, 16, 1)\\\\n    \\\\n    #Boss Stage\\\\n    for time in range(21, 30, 2):\\\\n        plan.add_wave(Bee, 3, time, 2)\\\\n    plan.add_wave(Wasp, 3, 22, 2)\\\\n    plan.add_wave(Hornet, 3, 24, 2)\\\\n    plan.add_wave(NinjaBee, 3, 26, 2)\\\\n    plan.add_wave(Hornet, 3, 28, 2)\\\\n    plan.add_wave(Boss, 20, 30, 1)\\\\n    return plan\\\\n\\\\ndef make_hard_assault_plan():\\\\n    plan = AssaultPlan()\\\\n    for time in range(3, 16, 2):\\\\n        plan.add_wave(Bee, 4, time, 2)\\\\n    plan.add_wave(Hornet, 4, 4, 2)\\\\n    plan.add_wave(Wasp, 4, 8, 2)\\\\n    plan.add_wave(NinjaBee, 4, 12, 2)\\\\n    plan.add_wave(Wasp, 4, 16, 2)\\\\n    \\\\n    #Boss Stage\\\\n    for time in range(21, 30, 2):\\\\n        plan.add_wave(Bee, 4, time, 3)\\\\n    plan.add_wave(Wasp, 4, 22, 2)\\\\n    plan.add_wave(Hornet, 4, 24, 2)\\\\n    plan.add_wave(NinjaBee, 4, 26, 2)\\\\n    plan.add_wave(Hornet, 4, 28, 2)\\\\n    plan.add_wave(Boss, 30, 30, 1)\\\\n    return plan\\\\n\\\\ndef make_insane_assault_plan():\\\\n    plan = AssaultPlan()\\\\n    plan.add_wave(Hornet, 5, 2, 2)\\\\n    for time in range(3, 16, 2):\\\\n        plan.add_wave(Bee, 5, time, 2)\\\\n    plan.add_wave(Hornet, 5, 4, 2)\\\\n    plan.add_wave(Wasp, 5, 8, 2)\\\\n    plan.add_wave(NinjaBee, 5, 12, 2)\\\\n    plan.add_wave(Wasp, 5, 16, 2)\\\\n    \\\\n    #Boss Stage\\\\n    for time in range(21, 30, 2):\\\\n        plan.add_wave(Bee, 5, time, 3)\\\\n    plan.add_wave(Wasp, 5, 22, 2)\\\\n    plan.add_wave(Hornet, 5, 24, 2)\\\\n    plan.add_wave(NinjaBee, 5, 26, 2)\\\\n    plan.add_wave(Hornet, 5, 28, 2)\\\\n    plan.add_wave(Boss, 30, 30, 2)\\\\n    return plan\\\\n\\\\n\\\\nfrom utils import *\\\\n@main\\\\ndef run(*args):\\\\n    Insect.reduce_armor = class_method_wrapper(Insect.reduce_armor,\\\\n            pre=print_expired_insects)\\\\n    start_with_strategy(args, interactive_strategy)\\\\n'}\"",
        "url": "http://www.cs61a.org/proj/ants",
        "zip_file_url": null
    },
    "client_time": null,
    "created": "2015-07-28 21:38:27.276490",
    "id": 5300231214202880,
    "messages": {
        "analytics": {
            "started": {
                "Problem 1": true,
                "Problem 2": true,
                "Problem 3A": true,
                "Problem 3B": true,
                "Problem 4A": true,
                "Problem 4B": true,
                "Problem 5A": true,
                "Problem 5B": true,
                "Problem 6A": true,
                "Problem 6B": true,
                "Problem 7": true,
                "Problem 8": true,
                "Problem 9": true,
                "Problem EC": true
            },
            "time": "2015-07-28 21:38:27.276490",
            "unlock": false
        },
        "file_contents": {
            "ants.py": "\"\"\"The ants module implements game logic for Ants Vs. SomeBees.\"\"\"\n\nimport random\nimport sys\nfrom ucb import main, interact, trace\nfrom collections import OrderedDict\n\n\n################\n# Core Classes #\n################\n\nclass Place(object):\n\t\"\"\"A Place holds insects and has an exit to another Place.\"\"\"\n\n\tdef __init__(self, name, exit=None):\n\t\t\"\"\"Create a Place with the given exit.\n\n\t\tname -- A string; the name of this Place.\n\t\texit -- The Place reached by exiting this Place (may be None).\n\t\t\"\"\"\n\t\tself.name = name\n\t\tself.exit = exit\n\t\tself.bees = []        # A list of Bees\n\t\tself.ant = None       # An Ant\n\t\tself.entrance = None  # A Place\n\t\t# Phase 1: Add an entrance to the exit\n\t\t# BEGIN Problem 2\n\t\tif self.exit != None:\n\t\t\tself.exit.entrance = self\n\t\t# END Problem 2\n\n\tdef add_insect(self, insect):\n\t\t\"\"\"Add an Insect to this Place.\n\n\t\tThere can be at most one Ant in a Place, unless exactly one of them is\n\t\ta BodyguardAnt (Phase 4), in which case there can be two. If add_insect\n\t\ttries to add more Ants than is allowed, an assertion error is raised.\n\n\t\tThere can be any number of Bees in a Place.\n\t\t\"\"\"\n\t\tif insect.is_ant:\n\t\t\t# Phase 4: Special handling for BodyguardAnt\n\t\t\t# BEGIN Problem 7\n\t\t\tif not self.ant:\n\t\t\t\tself.ant = insect\n\t\t\telse:\n\t\t\t\tif self.ant.container and self.ant.can_contain(insect):\n\t\t\t\t\tself.ant.contain_ant(insect)\n\t\t\t\telif insect.container and insect.can_contain(self.ant):\n\t\t\t\t\tinsect.contain_ant(self.ant)\n\t\t\t\t\tself.ant = insect\n\t\t\t\telse:\n\t\t\t\t\tassert self.ant is None, 'Two ants in {0}'.format(self)\n\t\t\t# END Problem 7\n\t\telse:\n\t\t\tself.bees.append(insect)\n\t\tinsect.place = self\n\n\tdef remove_insect(self, insect):\n\t\t\"\"\"Remove an Insect from this Place.\"\"\"\n\t\tif insect.is_ant:\n\t\t\t# Handle removal if insect is contained in self.ant\n\t\t\tassert self.ant is insect or self.ant.ant is insect, '{0} is not in {1}'.format(insect, self)\n\t\t\t# Phase 4: Special handling for BodyguardAnt and QueenAnt\n\t\t\t# BEGIN Problem 7\n\t\t\tif insect.name == 'Queen' and insect.num == 0:\n\t\t\t\treturn\n\t\t\tif self.ant == insect:\n\t\t\t\tif self.ant.container:\n\t\t\t\t\tself.ant = self.ant.ant\n\t\t\t\telse:\n\t\t\t\t\tself.ant = None\n\t\t\telse:\n\t\t\t\tself.ant.ant = None\n\t\t\t# END Problem 7\n\t\telse:\n\t\t\tself.bees.remove(insect)\n\n\t\tinsect.place = None\n\n\tdef __str__(self):\n\t\treturn self.name\n\n\nclass Insect(object):\n\t\"\"\"An Insect, the base class of Ant and Bee, has armor and a Place.\"\"\"\n\n\tis_ant = False\n\tdamage = 0\n\twatersafe = False\n\tdef __init__(self, armor, place=None):\n\t\t\"\"\"Create an Insect with an armor amount and a starting Place.\"\"\"\n\t\tself.armor = armor\n\t\tself.place = place  # set by Place.add_insect and Place.remove_insect\n\n\tdef reduce_armor(self, amount):\n\t\t\"\"\"Reduce armor by amount, and remove the insect from its place if it\n\t\thas no armor remaining.\n\n\t\t>>> test_insect = Insect(5)\n\t\t>>> test_insect.reduce_armor(2)\n\t\t>>> test_insect.armor\n\t\t3\n\t\t\"\"\"\n\t\tself.armor -= amount\n\t\tif self.armor <= 0:\n\t\t\tself.place.remove_insect(self)\n\n\tdef action(self, colony):\n\t\t\"\"\"The action performed each turn.\n\n\t\tcolony -- The AntColony, used to access game state information.\n\t\t\"\"\"\n\n\tdef __repr__(self):\n\t\tcname = type(self).__name__\n\t\treturn '{0}({1}, {2})'.format(cname, self.armor, self.place)\n\n\nclass Bee(Insect):\n\t\"\"\"A Bee moves from place to place, following exits and stinging ants.\"\"\"\n\n\tname = 'Bee'\n\tdamage = 1\n\twatersafe = True\n\tdef sting(self, ant):\n\t\t\"\"\"Attack an Ant, reducing the Ant's armor by 1.\"\"\"\n\t\tant.reduce_armor(self.damage)\n\n\tdef move_to(self, place):\n\t\t\"\"\"Move from the Bee's current Place to a new Place.\"\"\"\n\t\tself.place.remove_insect(self)\n\t\tplace.add_insect(self)\n\n\tdef blocked(self):\n\t\t\"\"\"Return True if this Bee cannot advance to the next Place.\"\"\"\n\t\t# Phase 3: Special handling for NinjaAnt\n\t\t# BEGIN Problem 6A\n\t\treturn (self.place.ant is not None) and self.place.ant.blocks_path\n\t\t# END Problem 6A\n\n\tdef action(self, colony):\n\t\t\"\"\"A Bee's action stings the Ant that blocks its exit if it is blocked,\n\t\tor moves to the exit of its current place otherwise.\n\n\t\tcolony -- The AntColony, used to access game state information.\n\t\t\"\"\"\n\t\tif self.blocked():\n\t\t\tself.sting(self.place.ant)\n\t\telif self.armor > 0 and self.place.exit is not None:\n\t\t\tself.move_to(self.place.exit)\n\nclass Ant(Insect):\n\t\"\"\"An Ant occupies a place and does work for the colony.\"\"\"\n\tblocks_path = True\n\tis_ant = True\n\timplemented = False  # Only implemented Ant classes should be instantiated\n\tfood_cost = 0\n\tcontainer = False\n\tname = 'Ants'\n\tdef __init__(self, armor=1):\n\t\t\"\"\"Create an Ant with an armor quantity.\"\"\"\n\t\tInsect.__init__(self, armor)\n\tdef can_contain(self, other):\n\t\treturn self.container and not self.ant and not other.container\n\n\nclass HarvesterAnt(Ant):\n\t\"\"\"HarvesterAnt produces 1 additional food per turn for the colony.\"\"\"\n\n\tname = 'Harvester'\n\timplemented = True\n\tfood_cost = 2\n\tdef action(self, colony):\n\t\t\"\"\"Produce 1 additional food for the colony.\n\n\t\tcolony -- The AntColony, used to access game state information.\n\t\t\"\"\"\n\t\t# BEGIN Problem 1\n\t\tcolony.food += 1\n\t\t# END Problem 1\n\n\nclass ThrowerAnt(Ant):\n\t\"\"\"ThrowerAnt throws a leaf each turn at the nearest Bee in its range.\"\"\"\n\n\tname = 'Thrower'\n\timplemented = True\n\tdamage = 1\n\tfood_cost = 4\n\tmin_range = 0\n\tmax_range = float('inf')\n\tdef nearest_bee(self, hive):\n\t\t\"\"\"Return the nearest Bee in a Place that is not the Hive, connected to\n\t\tthe ThrowerAnt's Place by following entrances.\n\n\t\tThis method returns None if there is no such Bee (or none in range).\n\t\t\"\"\"\n\t\t# BEGIN Problem 3B\n\t\tplace_now = self.place\n\t\tcurrent_range = 0\n\t\twhile place_now != hive and current_range <= self.max_range:\n\t\t\tif place_now.bees == [] or current_range < self.min_range:\n\t\t\t\tplace_now = place_now.entrance\n\t\t\telse:\n\t\t\t\treturn random_or_none(place_now.bees)\n\t\t\tcurrent_range += 1\n\t\t# END Problem 3B\n\n\tdef throw_at(self, target):\n\t\t\"\"\"Throw a leaf at the target Bee, reducing its armor.\"\"\"\n\t\tif target is not None:\n\t\t\ttarget.reduce_armor(self.damage)\n\n\tdef action(self, colony):\n\t\t\"\"\"Throw a leaf at the nearest Bee in range.\"\"\"\n\t\tself.throw_at(self.nearest_bee(colony.hive))\n\n\t\t\ndef random_or_none(s):\n\t\"\"\"Return a random element of sequence s, or return None if s is empty.\"\"\"\n\tif s:\n\t\treturn random.choice(s)\n\n\n##############\n# Extensions #\n##############\n\nclass Water(Place):\n\t\"\"\"Water is a place that can only hold 'watersafe' insects.\"\"\"\n\n\tdef add_insect(self, insect):\n\t\t\"\"\"Add insect if it is watersafe, otherwise reduce its armor to 0.\"\"\"\n\t\t# BEGIN Problem 3A\n\t\tPlace.add_insect(self, insect)\n\t\tif not insect.watersafe:\n\t\t\tinsect.reduce_armor(insect.armor)\n\t\t# END Problem 3A\n\n\nclass FireAnt(Ant):\n\t\"\"\"FireAnt cooks any Bee in its Place when it expires.\"\"\"\n\tname = 'Fire'\n\tdamage = 3\n\t# BEGIN Problem 4A\n\tfood_cost = 6\n\timplemented = True   # Change to True when finished, to view in GUI\n\t# END Problem 4A\n\tdef reduce_armor(self, amount):\n\t\t# BEGIN Problem 4A\n\t\tself.armor -= amount\n\t\tif self.armor <= 0:\n\t\t\tfor bee in list(self.place.bees):\n\t\t\t\tbee.reduce_armor(self.damage)\n\t\t\tself.place.remove_insect(self)\n\t\t\t\n\t\t# END Problem 4A\n\n\nclass LongThrower(ThrowerAnt):\n\t\"\"\"A ThrowerAnt that only throws leaves at Bees at least 5 places away.\"\"\"\n\tfood_cost = 2\n\tname = 'Long'\n\t# BEGIN Problem 4B\n\tmin_range = 5\n\timplemented = True   # Change to True when finished, to view in GUI\n\t# END Problem 4B\n\n\nclass ShortThrower(ThrowerAnt):\n\t\"\"\"A ThrowerAnt that only throws leaves at Bees at most 3 places away.\"\"\"\n\tfood_cost = 2\n\tname = 'Short'\n\t# BEGIN Problem 4B\n\tmax_range = 3\n\timplemented = True   # Change to True when finished, to view in GUI\n\t# END Problem 4B\n\n# BEGIN Problem 5A\nclass WallAnt(Ant):\n\tname = 'Wall'\n\tfood_cost = 4\n\tdef __init__(self):\n\t\tAnt.__init__(self, 4)\n\timplemented = True\n# The WallAnt class\n# END Problem 5A\n\n\nclass NinjaAnt(Ant):\n\t\"\"\"NinjaAnt does not block the path and damages all bees in its place.\"\"\"\n\tname = 'Ninja'\n\tdamage = 1\n\t# BEGIN Problem 6A\n\tblocks_path = False\n\tfood_cost = 6\n\timplemented = True   # Change to True when finished, to view in GUI\n\t# END Problem 6A\n\n\tdef action(self, colony):\n\t\t# BEGIN Problem 6A\n\t\tfor bee in list(self.place.bees):\n\t\t\tbee.reduce_armor(self.damage)\n\t\t# END Problem 6A\n\n\n# BEGIN Problem 5B\nclass ScubaThrower(ThrowerAnt):\n\twatersafe = True\n\tname = 'Scuba'\n\tfood_cost = 5\n\timplemented = True\n# The ScubaThrower class\n# END Problem 5B\n\n\nclass HungryAnt(Ant):\n\t\"\"\"HungryAnt will take three turns to digest a Bee in its place.\n\tWhile digesting, the HungryAnt can't eat another Bee.\n\t\"\"\"\n\tname = 'Hungry'\n\t# BEGIN Problem 6B\n\tfood_cost = 4\n\ttime_to_digest = 3\n\timplemented = True   # Change to True when finished, to view in GUI\n\t# END Problem 6B\n\n\tdef __init__(self):\n\t\t# BEGIN Problem 6B\n\t\tAnt.__init__(self)\n\t\tself.digesting = 0\n\t\t# END Problem 6B\n\n\tdef eat_bee(self, bee):\n\t\t# BEGIN Problem 6B\n\t\tbee.reduce_armor(bee.armor)\n\t\tself.digesting = self.time_to_digest\n\t\t# END Problem 6B\n\n\tdef action(self, colony):\n\t\t# BEGIN Problem 6B\n\t\tif not self.digesting and self.place.bees != []:\n\t\t\tself.eat_bee(random_or_none(self.place.bees))\n\t\telif self.digesting:\n\t\t\tself.digesting -= 1\n\t\t# END Problem 6B\n\n\nclass BodyguardAnt(Ant):\n\t\"\"\"BodyguardAnt provides protection to other Ants.\"\"\"\n\tname = 'Bodyguard'\n\t# BEGIN Problem 7\n\tcontainer = True\n\tfood_cost = 4\n\timplemented = True   # Change to True when finished, to view in GUI\n\t# END Problem 7\n\n\tdef __init__(self):\n\t\tAnt.__init__(self, 2)\n\t\tself.ant = None  # The Ant hidden in this bodyguard\n\n\tdef contain_ant(self, ant):\n\t\t# BEGIN Problem 7\n\t\tif self.can_contain(ant):\n\t\t\tself.ant = ant\n\t\t# END Problem 7\n\n\tdef action(self, colony):\n\t\t# BEGIN Problem 7\n\t\tif self.ant:\n\t\t\tself.ant.action(colony)\n\t\t# END Problem 7\n\nclass TankAnt(BodyguardAnt):\n\t\"\"\"TankAnt provides both offensive and defensive capabilities.\"\"\"\n\tname = 'Tank'\n\t# BEGIN Problem 8\n\tfood_cost = 6\n\tdamage = 1\n\timplemented = True   # Change to True when finished, to view in GUI\n\t# END Problem 8\n\n\tdef action(self, colony):\n\t\t# BEGIN Problem 8\n\t\tif self.ant:\n\t\t\tself.ant.action(colony)\n\t\tfor bee in list(self.place.bees):\n\t\t\tbee.reduce_armor(self.damage)\n\t\t# END Problem 8\n\nclass QueenPlace(object):\n\t\"\"\"A place that represents both places in which the bees find the queen.\n\n\t(1) The original colony queen location at the end of all tunnels, and\n\t(2) The place in which the QueenAnt resides.\n\t\"\"\"\n\tdef __init__(self, colony_queen, ant_queen):\n\t\t# BEGIN Problem 9\n\t\tself.colony_place = colony_queen\n\t\tself.queen_place = ant_queen\n\t\tself.name = 'queenplace'\n\t\t# END Problem 9\n\n\t@property\n\tdef bees(self):\n\t\t# BEGIN Problem 9\n\t\treturn self.colony_place.bees + self.queen_place.bees\n\t\t# END Problem 9\n\n\nclass QueenAnt(ScubaThrower):  # You should change this line\n\t\"\"\"The Queen of the colony.  The game is over if a bee enters her place.\"\"\"\n\tnum_queen = 0\n\tname = 'Queen'\n\t# BEGIN Problem 9\n\tfood_cost = 6\n\timplemented = True   # Change to True when finished, to view in GUI\n\t# END Problem 9\n\n\tdef __init__(self):\n\t\t# BEGIN Problem 9\n\t\tAnt.__init__(self, 1)\n\t\tself.num = QueenAnt.num_queen\n\t\tQueenAnt.num_queen += 1\n\t\tself.antsbuff = [self]\n\t\t# END Problem 9\n\n\tdef action(self, colony):\n\t\t\"\"\"A queen ant throws a leaf, but also doubles the damage of ants\n\t\tin her tunnel.\n\n\t\tImpostor queens do only one thing: reduce their own armor to 0.\n\t\t\"\"\"\n\t\t# BEGIN Problem 9\n\t\tif self.num > 0:\n\t\t\tself.reduce_armor(self.armor)\n\t\telse:\n\t\t\tif colony.queen.name == 'AntQueen':\n\t\t\t\tcolony.queen = QueenPlace(colony.queen, self.place)\n\t\t\tself.throw_at(self.nearest_bee(colony.hive))\n\t\t\tbuff_place = self.place\n\t\t\twhile buff_place != None:\n\t\t\t\tif buff_place.ant != None:\n\t\t\t\t\tif buff_place.ant.container and buff_place.ant.ant and \\\n\t\t\t\t\t\tbuff_place.ant.ant not in self.antsbuff:\n\t\t\t\t\t\tbuff_place.ant.ant.damage = 2*buff_place.ant.ant.damage\n\t\t\t\t\t\tself.antsbuff += [buff_place.ant.ant]\n\t\t\t\t\tif buff_place.ant not in self.antsbuff:\n\t\t\t\t\t\tbuff_place.ant.damage = 2*buff_place.ant.damage\n\t\t\t\t\t\tself.antsbuff += [buff_place.ant]\n\t\t\t\tbuff_place = buff_place.exit\n\n\n\t\t# END Problem 9\n\n\nclass AntRemover(Ant):\n\t\"\"\"Allows the player to remove ants from the board in the GUI.\"\"\"\n\n\tname = 'Remover'\n\timplemented = True\n\n\tdef __init__(self):\n\t\tAnt.__init__(self, 0)\n\n\n##################\n# Status Effects #\n##################\n\ndef make_slow(action):\n\t\"\"\"Return a new action method that calls action every other turn.\n\n\taction -- An action method of some Bee\n\t\"\"\"\n\t# BEGIN Problem EC\n\tdef slow(colony):\n\t\tif colony.time % 2 == 0:\n\t\t\taction(colony)\n\treturn slow\n\t\t\t \n\t# END Problem EC\n\ndef make_stun(action):\n\t\"\"\"Return a new action method that does nothing.\n\n\taction -- An action method of some Bee\n\t\"\"\"\n\t# BEGIN Problem EC\n\tdef stun(colony):\n\t\treturn\n\treturn stun\n\t# END Problem EC\n\ndef apply_effect(effect, bee, duration):\n\t\"\"\"Apply a status effect to a Bee that lasts for duration turns.\"\"\"\n\t# BEGIN Problem EC\n\tori_act = bee.action\n\tdef new_act(colony):\n\t\tnonlocal duration\n\t\tif duration > 0:\n\t\t\teffect(ori_act)(colony)\n\t\t\tduration -= 1\n\t\telse:\n\t\t\tori_act(colony)\n\tbee.action = new_act\n\t# END Problem EC\n\n\nclass SlowThrower(ThrowerAnt):\n\t\"\"\"ThrowerAnt that causes Slow on Bees.\"\"\"\n\n\tname = 'Slow'\n\t# BEGIN Problem EC\n\tfood_cost = 4\n\timplemented = True   # Change to True when finished, to view in GUI\n\t# END Problem EC\n\n\tdef throw_at(self, target):\n\t\tif target:\n\t\t\tapply_effect(make_slow, target, 3)\n\n\nclass StunThrower(ThrowerAnt):\n\t\"\"\"ThrowerAnt that causes Stun on Bees.\"\"\"\n\n\tname = 'Stun'\n\t# BEGIN Problem EC\n\tfood_cost = 6\n\timplemented = True \t # Change to True when finished, to view in GUI\n\t# END Problem EC\n\n\tdef throw_at(self, target):\n\t\tif target:\n\t\t\tapply_effect(make_stun, target, 1)\n\n\n##################\n# Bees Extension #\n##################\n\nclass Wasp(Bee):\n\t\"\"\"Class of Bee that has higher damage.\"\"\"\n\tname = 'Wasp'\n\tdamage = 2\n\nclass Hornet(Bee):\n\t\"\"\"Class of bee that is capable of taking two actions per turn, although\n\tits overall damage output is lower. Immune to status effects.\n\t\"\"\"\n\tname = 'Hornet'\n\tdamage = 0.25\n\n\tdef action(self, colony):\n\t\tfor i in range(2):\n\t\t\tif self.armor > 0:\n\t\t\t\tsuper().action(colony)\n\n\tdef __setattr__(self, name, value):\n\t\tif name != 'action':\n\t\t\tobject.__setattr__(self, name, value)\n\nclass NinjaBee(Bee):\n\t\"\"\"A Bee that cannot be blocked. Is capable of moving past all defenses to\n\tassassinate the Queen.\n\t\"\"\"\n\tname = 'NinjaBee'\n\n\tdef blocked(self):\n\t\treturn False\n\t\t\t\nclass Boss(Wasp, Hornet):\n\t\"\"\"The leader of the bees. Combines the high damage of the Wasp along with\n\tstatus effect immunity of Hornets. Damage to the boss is capped up to 8\n\tdamage by a single attack.\n\t\"\"\"\n\tname = 'Boss'\n\tdamage_cap = 8\n\taction = Wasp.action\n\n\tdef reduce_armor(self, amount):\n\t\tsuper().reduce_armor(self.damage_modifier(amount))\n\n\tdef damage_modifier(self, amount):\n\t\treturn amount * self.damage_cap/(self.damage_cap + amount)\n\nclass Hive(Place):\n\t\"\"\"The Place from which the Bees launch their assault.\n\n\tassault_plan -- An AssaultPlan; when & where bees enter the colony.\n\t\"\"\"\n\n\tdef __init__(self, assault_plan):\n\t\tself.name = 'Hive'\n\t\tself.assault_plan = assault_plan\n\t\tself.bees = []\n\t\tfor bee in assault_plan.all_bees:\n\t\t\tself.add_insect(bee)\n\t\t# The following attributes are always None for a Hive\n\t\tself.entrance = None\n\t\tself.ant = None\n\t\tself.exit = None\n\n\tdef strategy(self, colony):\n\t\texits = [p for p in colony.places.values() if p.entrance is self]\n\t\tfor bee in self.assault_plan.get(colony.time, []):\n\t\t\tbee.move_to(random.choice(exits))\n\t\t\tcolony.active_bees.append(bee)\n\n\nclass AntColony(object):\n\t\"\"\"An ant collective that manages global game state and simulates time.\n\n\tAttributes:\n\ttime -- elapsed time\n\tfood -- the colony's available food total\n\tqueen -- the place where the queen resides\n\tplaces -- A list of all places in the colony (including a Hive)\n\tbee_entrances -- A list of places that bees can enter\n\t\"\"\"\n\n\tdef __init__(self, strategy, hive, ant_types, create_places, dimensions, food=2):\n\t\t\"\"\"Create an AntColony for simulating a game.\n\n\t\tArguments:\n\t\tstrategy -- a function to deploy ants to places\n\t\thive -- a Hive full of bees\n\t\tant_types -- a list of ant constructors\n\t\tcreate_places -- a function that creates the set of places\n\t\tdimensions -- a pair containing the dimensions of the game layout\n\t\t\"\"\"\n\t\tself.time = 0\n\t\tself.food = food\n\t\tself.strategy = strategy\n\t\tself.hive = hive\n\t\tself.ant_types = OrderedDict((a.name, a) for a in ant_types)\n\t\tself.dimensions = dimensions\n\t\tself.active_bees = []\n\t\tself.configure(hive, create_places)\n\n\tdef configure(self, hive, create_places):\n\t\t\"\"\"Configure the places in the colony.\"\"\"\n\t\tself.queen = Place('AntQueen')\n\t\tself.places = OrderedDict()\n\t\tself.bee_entrances = []\n\t\tdef register_place(place, is_bee_entrance):\n\t\t\tself.places[place.name] = place\n\t\t\tif is_bee_entrance:\n\t\t\t\tplace.entrance = hive\n\t\t\t\tself.bee_entrances.append(place)\n\t\tregister_place(self.hive, False)\n\t\tcreate_places(self.queen, register_place, self.dimensions[0], self.dimensions[1])\n\n\tdef simulate(self):\n\t\t\"\"\"Simulate an attack on the ant colony (i.e., play the game).\"\"\"\n\t\tnum_bees = len(self.bees)\n\t\twhile len(self.queen.bees) == 0 and num_bees > 0:\n\t\t\tself.hive.strategy(self)            # Bees invade\n\t\t\tself.strategy(self)                 # Ants deploy\n\t\t\tfor ant in self.ants:               # Ants take actions\n\t\t\t\tif ant.armor > 0:\n\t\t\t\t\tant.action(self)\n\t\t\tfor bee in self.active_bees[:]:     # Bees take actions\n\t\t\t\tif bee.armor > 0:\n\t\t\t\t\tbee.action(self)\n\t\t\t\tif bee.armor <= 0:\n\t\t\t\t\tnum_bees -= 1\n\t\t\t\t\tself.active_bees.remove(bee)\n\t\t\tself.time += 1\n\t\tif len(self.queen.bees) > 0:\n\t\t\tprint('The ant queen has perished. Please try again.')\n\t\t\treturn False\n\t\telse:\n\t\t\tprint('All bees are vanquished. You win!')\n\t\t\treturn True\n\n\tdef deploy_ant(self, place_name, ant_type_name):\n\t\t\"\"\"Place an ant if enough food is available.\n\n\t\tThis method is called by the current strategy to deploy ants.\n\t\t\"\"\"\n\t\tconstructor = self.ant_types[ant_type_name]\n\t\tif self.food < constructor.food_cost:\n\t\t\tprint('Not enough food remains to place ' + ant_type_name)\n\t\telse:\n\t\t\tant = constructor()\n\t\t\tself.places[place_name].add_insect(ant)\n\t\t\tself.food -= constructor.food_cost\n\t\t\treturn ant\n\n\tdef remove_ant(self, place_name):\n\t\t\"\"\"Remove an Ant from the Colony.\"\"\"\n\t\tplace = self.places[place_name]\n\t\tif place.ant is not None:\n\t\t\tplace.remove_insect(place.ant)\n\n\t@property\n\tdef ants(self):\n\t\treturn [p.ant for p in self.places.values() if p.ant is not None]\n\n\t@property\n\tdef bees(self):\n\t\treturn [b for p in self.places.values() for b in p.bees]\n\n\t@property\n\tdef insects(self):\n\t\treturn self.ants + self.bees\n\n\tdef __str__(self):\n\t\tstatus = ' (Food: {0}, Time: {1})'.format(self.food, self.time)\n\t\treturn str([str(i) for i in self.ants + self.bees]) + status\n\n\ndef ant_types():\n\t\"\"\"Return a list of all implemented Ant classes.\"\"\"\n\tall_ant_types = []\n\tnew_types = [Ant]\n\twhile new_types:\n\t\tnew_types = [t for c in new_types for t in c.__subclasses__()]\n\t\tall_ant_types.extend(new_types)\n\treturn [t for t in all_ant_types if t.implemented]\n\ndef interactive_strategy(colony):\n\t\"\"\"A strategy that starts an interactive session and lets the user make\n\tchanges to the colony.\n\n\tFor example, one might deploy a ThrowerAnt to the first tunnel by invoking\n\tcolony.deploy_ant('tunnel_0_0', 'Thrower')\n\t\"\"\"\n\tprint('colony: ' + str(colony))\n\tmsg = '<Control>-D (<Control>-Z <Enter> on Windows) completes a turn.\\n'\n\tinteract(msg)\n\ndef start_with_strategy(args, strategy):\n\t\"\"\"Reads command-line arguments and starts a game with those options.\"\"\"\n\timport argparse\n\tparser = argparse.ArgumentParser(description=\"Play Ants vs. SomeBees\")\n\tparser.add_argument('-d', type=str, metavar='DIFFICULTY',\n\t\t\t\t\t\thelp='sets difficulty of game (easy/medium/hard/insane)')\n\tparser.add_argument('-w', '--water', action='store_true',\n\t\t\t\t\t\thelp='loads a full layout with water')\n\tparser.add_argument('--food', type=int,\n\t\t\t\t\t\thelp='number of food to start with when testing', default=2)\n\targs = parser.parse_args()\n\n\tassault_plan = make_test_assault_plan()\n\tlayout = dry_layout\n\ttunnel_length = 9\n\tnum_tunnels = 1\n\tfood = args.food\n\n\tif args.water:\n\t\tlayout = wet_layout\n\tif args.d in ['e', 'easy']:\n\t\tassault_plan = make_easy_assault_plan()\n\t\tnum_tunnels = 2\n\t\tfood = 2\n\telif args.d in ['n', 'normal']:\n\t\tassault_plan = make_normal_assault_plan()\n\t\tnum_tunnels = 3\n\t\tfood = 2\n\telif args.d in ['h', 'hard']:\n\t\tassault_plan = make_hard_assault_plan()\n\t\tnum_tunnels = 4\n\t\tfood = 2\n\telif args.d in ['i', 'insane']:\n\t\tassault_plan = make_insane_assault_plan()\n\t\tnum_tunnels = 4\n\t\tfood = 2\n\n\thive = Hive(assault_plan)\n\tdimensions = (num_tunnels, tunnel_length)\n\treturn AntColony(strategy, hive, ant_types(), layout, dimensions, food).simulate()\n\n\n###########\n# Layouts #\n###########\n\ndef wet_layout(queen, register_place, tunnels=3, length=9, moat_frequency=3):\n\t\"\"\"Register a mix of wet and and dry places.\"\"\"\n\tfor tunnel in range(tunnels):\n\t\texit = queen\n\t\tfor step in range(length):\n\t\t\tif moat_frequency != 0 and (step + 1) % moat_frequency == 0:\n\t\t\t\texit = Water('water_{0}_{1}'.format(tunnel, step), exit)\n\t\t\telse:\n\t\t\t\texit = Place('tunnel_{0}_{1}'.format(tunnel, step), exit)\n\t\t\tregister_place(exit, step == length - 1)\n\ndef dry_layout(queen, register_place, tunnels=3, length=9):\n\t\"\"\"Register dry tunnels.\"\"\"\n\twet_layout(queen, register_place, tunnels, length, 0)\n\n\n#################\n# Assault Plans #\n#################\n\nclass AssaultPlan(dict):\n\t\"\"\"The Bees' plan of attack for the Colony.  Attacks come in timed waves.\n\n\tAn AssaultPlan is a dictionary from times (int) to waves (list of Bees).\n\n\t>>> AssaultPlan().add_wave(4, 2)\n\t{4: [Bee(3, None), Bee(3, None)]}\n\t\"\"\"\n\n\tdef add_wave(self, bee_type, bee_armor, time, count):\n\t\t\"\"\"Add a wave at time with count Bees that have the specified armor.\"\"\"\n\t\tbees = [bee_type(bee_armor) for _ in range(count)]\n\t\tself.setdefault(time, []).extend(bees)\n\t\treturn self\n\n\t@property\n\tdef all_bees(self):\n\t\t\"\"\"Place all Bees in the hive and return the list of Bees.\"\"\"\n\t\treturn [bee for wave in self.values() for bee in wave]\n\ndef make_test_assault_plan():\n\treturn AssaultPlan().add_wave(Bee, 3, 2, 1).add_wave(Bee, 3, 3, 1)\n\ndef make_easy_assault_plan():\n\tplan = AssaultPlan()\n\tfor time in range(3, 16, 2):\n\t\tplan.add_wave(Bee, 3, time, 1)\n\tplan.add_wave(Wasp, 3, 4, 1)\n\tplan.add_wave(NinjaBee, 3, 8, 1)\n\tplan.add_wave(Hornet, 3, 12, 1)\n\tplan.add_wave(Boss, 15, 16, 1)\n\treturn plan\n\ndef make_normal_assault_plan():\n\tplan = AssaultPlan()\n\tfor time in range(3, 16, 2):\n\t\tplan.add_wave(Bee, 3, time, 2)\n\tplan.add_wave(Wasp, 3, 4, 1)\n\tplan.add_wave(NinjaBee, 3, 8, 1)\n\tplan.add_wave(Hornet, 3, 12, 1)\n\tplan.add_wave(Wasp, 3, 16, 1)\n\t\n\t#Boss Stage\n\tfor time in range(21, 30, 2):\n\t\tplan.add_wave(Bee, 3, time, 2)\n\tplan.add_wave(Wasp, 3, 22, 2)\n\tplan.add_wave(Hornet, 3, 24, 2)\n\tplan.add_wave(NinjaBee, 3, 26, 2)\n\tplan.add_wave(Hornet, 3, 28, 2)\n\tplan.add_wave(Boss, 20, 30, 1)\n\treturn plan\n\ndef make_hard_assault_plan():\n\tplan = AssaultPlan()\n\tfor time in range(3, 16, 2):\n\t\tplan.add_wave(Bee, 4, time, 2)\n\tplan.add_wave(Hornet, 4, 4, 2)\n\tplan.add_wave(Wasp, 4, 8, 2)\n\tplan.add_wave(NinjaBee, 4, 12, 2)\n\tplan.add_wave(Wasp, 4, 16, 2)\n\t\n\t#Boss Stage\n\tfor time in range(21, 30, 2):\n\t\tplan.add_wave(Bee, 4, time, 3)\n\tplan.add_wave(Wasp, 4, 22, 2)\n\tplan.add_wave(Hornet, 4, 24, 2)\n\tplan.add_wave(NinjaBee, 4, 26, 2)\n\tplan.add_wave(Hornet, 4, 28, 2)\n\tplan.add_wave(Boss, 30, 30, 1)\n\treturn plan\n\ndef make_insane_assault_plan():\n\tplan = AssaultPlan()\n\tplan.add_wave(Hornet, 5, 2, 2)\n\tfor time in range(3, 16, 2):\n\t\tplan.add_wave(Bee, 5, time, 2)\n\tplan.add_wave(Hornet, 5, 4, 2)\n\tplan.add_wave(Wasp, 5, 8, 2)\n\tplan.add_wave(NinjaBee, 5, 12, 2)\n\tplan.add_wave(Wasp, 5, 16, 2)\n\t\n\t#Boss Stage\n\tfor time in range(21, 30, 2):\n\t\tplan.add_wave(Bee, 5, time, 3)\n\tplan.add_wave(Wasp, 5, 22, 2)\n\tplan.add_wave(Hornet, 5, 24, 2)\n\tplan.add_wave(NinjaBee, 5, 26, 2)\n\tplan.add_wave(Hornet, 5, 28, 2)\n\tplan.add_wave(Boss, 30, 30, 2)\n\treturn plan\n\n\nfrom utils import *\n@main\ndef run(*args):\n\tInsect.reduce_armor = class_method_wrapper(Insect.reduce_armor,\n\t\t\tpre=print_expired_insects)\n\tstart_with_strategy(args, interactive_strategy)\n",
            "group_members_6740807637794816.json": "{\n    \"0\": \"binglinsong@berkeley.edu\",\n    \"1\": \"anthony0312@berkeley.edu\"\n}",
            "group_meta_6740807637794816.json": "{\n    \"assignment\": {\n        \"active\": false,\n        \"autograding_enabled\": false,\n        \"course\": {\n            \"active\": true,\n            \"created\": \"2015-06-20 07:52:12.138670\",\n            \"display_name\": \"CS 61A\",\n            \"id\": 5710200078073856,\n            \"institution\": \"UC Berkeley\",\n            \"instructor\": [],\n            \"offering\": \"cal/61A/su15\"\n        },\n        \"created\": \"2015-07-17 23:16:13.346110\",\n        \"creator\": {\n            \"created\": \"2015-02-02 17:10:40.000000\",\n            \"email\": [\n                \"greynotgray@berkeley.edu\"\n            ],\n            \"id\": 6593334940270592,\n            \"is_admin\": true\n        },\n        \"display_name\": \"Project 3: Ants\",\n        \"due_date\": \"2015-07-28 23:59:59.000000\",\n        \"grading_script_file\": \"# run as bash, your zip will be extracted into the folder\\n#layout: info.py grade.sh student_files extracted_zip_files\\n# CHANGE these lines: \\nmv lab01/* .;\\npython3 ok --local --score;\\n#Format: echo 'Score:\\\\n\\\\tTotal: 2.0\\\\nBlah\\\\nOk';\\n# Please cleanup your files\\nrm -rf ./*;\",\n        \"id\": 5876190422237184,\n        \"lock_date\": \"2015-08-14 23:59:59.000000\",\n        \"max_group_size\": 2,\n        \"name\": \"cal/cs61a/su15/proj3\",\n        \"points\": 23.0,\n        \"revision\": false,\n        \"templates\": \"\\\"{'ants.py':  '\\\\\\\"\\\\\\\"\\\\\\\"The ants module implements game logic for Ants Vs. SomeBees.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\nimport random\\\\\\\\nimport sys\\\\\\\\nfrom ucb import main, interact, trace\\\\\\\\nfrom collections import OrderedDict\\\\\\\\n\\\\\\\\n\\\\\\\\n################\\\\\\\\n# Core Classes #\\\\\\\\n################\\\\\\\\n\\\\\\\\nclass Place(object):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"A Place holds insects and has an exit to another Place.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    def __init__(self, name, exit=None):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Create a Place with the given exit.\\\\\\\\n\\\\\\\\n        name -- A string; the name of this Place.\\\\\\\\n        exit -- The Place reached by exiting this Place (may be None).\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        self.name = name\\\\\\\\n        self.exit = exit\\\\\\\\n        self.bees = []        # A list of Bees\\\\\\\\n        self.ant = None       # An Ant\\\\\\\\n        self.entrance = None  # A Place\\\\\\\\n        # Phase 1: Add an entrance to the exit\\\\\\\\n        # BEGIN Problem 2\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Problem 2\\\\\\\\n\\\\\\\\n    def add_insect(self, insect):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Add an Insect to this Place.\\\\\\\\n\\\\\\\\n        There can be at most one Ant in a Place, unless exactly one of them is\\\\\\\\n        a BodyguardAnt (Phase 4), in which case there can be two. If add_insect\\\\\\\\n        tries to add more Ants than is allowed, an assertion error is raised.\\\\\\\\n\\\\\\\\n        There can be any number of Bees in a Place.\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        if insect.is_ant:\\\\\\\\n            # Phase 4: Special handling for BodyguardAnt\\\\\\\\n            # BEGIN Problem 7\\\\\\\\n            \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n            # END Problem 7\\\\\\\\n            assert self.ant is None, \\\\\\\\'Two ants in {0}\\\\\\\\'.format(self)\\\\\\\\n            self.ant = insect\\\\\\\\n        else:\\\\\\\\n            self.bees.append(insect)\\\\\\\\n        insect.place = self\\\\\\\\n\\\\\\\\n    def remove_insect(self, insect):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Remove an Insect from this Place.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        if insect.is_ant:\\\\\\\\n            # Handle removal if insect is contained in self.ant\\\\\\\\n            assert self.ant is insect, \\\\\\\\'{0} is not in {1}\\\\\\\\'.format(insect, self)\\\\\\\\n            # Phase 4: Special handling for BodyguardAnt and QueenAnt\\\\\\\\n            # BEGIN Problem 7\\\\\\\\n            \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n            self.ant = None\\\\\\\\n            # END Problem 7\\\\\\\\n        else:\\\\\\\\n            self.bees.remove(insect)\\\\\\\\n\\\\\\\\n        insect.place = None\\\\\\\\n\\\\\\\\n    def __str__(self):\\\\\\\\n        return self.name\\\\\\\\n\\\\\\\\n\\\\\\\\nclass Insect(object):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"An Insect, the base class of Ant and Bee, has armor and a Place.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    is_ant = False\\\\\\\\n    damage = 0\\\\\\\\n\\\\\\\\n    def __init__(self, armor, place=None):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Create an Insect with an armor amount and a starting Place.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        self.armor = armor\\\\\\\\n        self.place = place  # set by Place.add_insect and Place.remove_insect\\\\\\\\n\\\\\\\\n    def reduce_armor(self, amount):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Reduce armor by amount, and remove the insect from its place if it\\\\\\\\n        has no armor remaining.\\\\\\\\n\\\\\\\\n        >>> test_insect = Insect(5)\\\\\\\\n        >>> test_insect.reduce_armor(2)\\\\\\\\n        >>> test_insect.armor\\\\\\\\n        3\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        self.armor -= amount\\\\\\\\n        if self.armor <= 0:\\\\\\\\n            self.place.remove_insect(self)\\\\\\\\n\\\\\\\\n    def action(self, colony):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"The action performed each turn.\\\\\\\\n\\\\\\\\n        colony -- The AntColony, used to access game state information.\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    def __repr__(self):\\\\\\\\n        cname = type(self).__name__\\\\\\\\n        return \\\\\\\\'{0}({1}, {2})\\\\\\\\'.format(cname, self.armor, self.place)\\\\\\\\n\\\\\\\\n\\\\\\\\nclass Bee(Insect):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"A Bee moves from place to place, following exits and stinging ants.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    name = \\\\\\\\'Bee\\\\\\\\'\\\\\\\\n    damage = 1\\\\\\\\n\\\\\\\\n    def sting(self, ant):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Attack an Ant, reducing the Ant\\\\\\\\'s armor by 1.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        ant.reduce_armor(self.damage)\\\\\\\\n\\\\\\\\n    def move_to(self, place):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Move from the Bee\\\\\\\\'s current Place to a new Place.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        self.place.remove_insect(self)\\\\\\\\n        place.add_insect(self)\\\\\\\\n\\\\\\\\n    def blocked(self):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Return True if this Bee cannot advance to the next Place.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        # Phase 3: Special handling for NinjaAnt\\\\\\\\n        # BEGIN Problem 6A\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        return self.place.ant is not None\\\\\\\\n        # END Problem 6A\\\\\\\\n\\\\\\\\n    def action(self, colony):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"A Bee\\\\\\\\'s action stings the Ant that blocks its exit if it is blocked,\\\\\\\\n        or moves to the exit of its current place otherwise.\\\\\\\\n\\\\\\\\n        colony -- The AntColony, used to access game state information.\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        if self.blocked():\\\\\\\\n            self.sting(self.place.ant)\\\\\\\\n        elif self.armor > 0 and self.place.exit is not None:\\\\\\\\n            self.move_to(self.place.exit)\\\\\\\\n\\\\\\\\n\\\\\\\\nclass Ant(Insect):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"An Ant occupies a place and does work for the colony.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    is_ant = True\\\\\\\\n    implemented = False  # Only implemented Ant classes should be instantiated\\\\\\\\n    food_cost = 0\\\\\\\\n\\\\\\\\n    def __init__(self, armor=1):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Create an Ant with an armor quantity.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        Insect.__init__(self, armor)\\\\\\\\n\\\\\\\\n\\\\\\\\nclass HarvesterAnt(Ant):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"HarvesterAnt produces 1 additional food per turn for the colony.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    name = \\\\\\\\'Harvester\\\\\\\\'\\\\\\\\n    implemented = True\\\\\\\\n\\\\\\\\n    def action(self, colony):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Produce 1 additional food for the colony.\\\\\\\\n\\\\\\\\n        colony -- The AntColony, used to access game state information.\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        # BEGIN Problem 1\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Problem 1\\\\\\\\n\\\\\\\\n\\\\\\\\nclass ThrowerAnt(Ant):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"ThrowerAnt throws a leaf each turn at the nearest Bee in its range.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    name = \\\\\\\\'Thrower\\\\\\\\'\\\\\\\\n    implemented = True\\\\\\\\n    damage = 1\\\\\\\\n\\\\\\\\n    def nearest_bee(self, hive):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Return the nearest Bee in a Place that is not the Hive, connected to\\\\\\\\n        the ThrowerAnt\\\\\\\\'s Place by following entrances.\\\\\\\\n\\\\\\\\n        This method returns None if there is no such Bee (or none in range).\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        # BEGIN Problem 3B\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        return random_or_none(self.place.bees)\\\\\\\\n        # END Problem 3B\\\\\\\\n\\\\\\\\n    def throw_at(self, target):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Throw a leaf at the target Bee, reducing its armor.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        if target is not None:\\\\\\\\n            target.reduce_armor(self.damage)\\\\\\\\n\\\\\\\\n    def action(self, colony):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Throw a leaf at the nearest Bee in range.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        self.throw_at(self.nearest_bee(colony.hive))\\\\\\\\n\\\\\\\\n        \\\\\\\\ndef random_or_none(s):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Return a random element of sequence s, or return None if s is empty.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    if s:\\\\\\\\n        return random.choice(s)\\\\\\\\n\\\\\\\\n\\\\\\\\n##############\\\\\\\\n# Extensions #\\\\\\\\n##############\\\\\\\\n\\\\\\\\nclass Water(Place):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Water is a place that can only hold \\\\\\\\'watersafe\\\\\\\\' insects.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    def add_insect(self, insect):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Add insect if it is watersafe, otherwise reduce its armor to 0.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        # BEGIN Problem 3A\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Problem 3A\\\\\\\\n\\\\\\\\n\\\\\\\\nclass FireAnt(Ant):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"FireAnt cooks any Bee in its Place when it expires.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    name = \\\\\\\\'Fire\\\\\\\\'\\\\\\\\n    damage = 3\\\\\\\\n    # BEGIN Problem 4A\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\\\\\n    # END Problem 4A\\\\\\\\n\\\\\\\\n    def reduce_armor(self, amount):\\\\\\\\n        # BEGIN Problem 4A\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Problem 4A\\\\\\\\n\\\\\\\\n\\\\\\\\nclass LongThrower(ThrowerAnt):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"A ThrowerAnt that only throws leaves at Bees at least 5 places away.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    name = \\\\\\\\'Long\\\\\\\\'\\\\\\\\n    # BEGIN Problem 4B\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\\\\\n    # END Problem 4B\\\\\\\\n\\\\\\\\n\\\\\\\\nclass ShortThrower(ThrowerAnt):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"A ThrowerAnt that only throws leaves at Bees at most 3 places away.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    name = \\\\\\\\'Short\\\\\\\\'\\\\\\\\n    # BEGIN Problem 4B\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\\\\\n    # END Problem 4B\\\\\\\\n\\\\\\\\n\\\\\\\\n# BEGIN Problem 5A\\\\\\\\n\\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n# The WallAnt class\\\\\\\\n# END Problem 5A\\\\\\\\n\\\\\\\\n\\\\\\\\nclass NinjaAnt(Ant):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"NinjaAnt does not block the path and damages all bees in its place.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    name = \\\\\\\\'Ninja\\\\\\\\'\\\\\\\\n    damage = 1\\\\\\\\n    # BEGIN Problem 6A\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\\\\\n    # END Problem 6A\\\\\\\\n\\\\\\\\n    def action(self, colony):\\\\\\\\n        # BEGIN Problem 6A\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Problem 6A\\\\\\\\n\\\\\\\\n\\\\\\\\n# BEGIN Problem 5B\\\\\\\\n\\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n# The ScubaThrower class\\\\\\\\n# END Problem 5B\\\\\\\\n\\\\\\\\n\\\\\\\\nclass HungryAnt(Ant):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"HungryAnt will take three turns to digest a Bee in its place.\\\\\\\\n    While digesting, the HungryAnt can\\\\\\\\'t eat another Bee.\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    name = \\\\\\\\'Hungry\\\\\\\\'\\\\\\\\n    # BEGIN Problem 6B\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\\\\\n    # END Problem 6B\\\\\\\\n\\\\\\\\n    def __init__(self):\\\\\\\\n        # BEGIN Problem 6B\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Problem 6B\\\\\\\\n\\\\\\\\n    def eat_bee(self, bee):\\\\\\\\n        # BEGIN Problem 6B\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Problem 6B\\\\\\\\n\\\\\\\\n    def action(self, colony):\\\\\\\\n        # BEGIN Problem 6B\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Problem 6B\\\\\\\\n\\\\\\\\n\\\\\\\\nclass BodyguardAnt(Ant):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"BodyguardAnt provides protection to other Ants.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    name = \\\\\\\\'Bodyguard\\\\\\\\'\\\\\\\\n    # BEGIN Problem 7\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\\\\\n    # END Problem 7\\\\\\\\n\\\\\\\\n    def __init__(self):\\\\\\\\n        Ant.__init__(self, 2)\\\\\\\\n        self.ant = None  # The Ant hidden in this bodyguard\\\\\\\\n\\\\\\\\n    def contain_ant(self, ant):\\\\\\\\n        # BEGIN Problem 7\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Problem 7\\\\\\\\n\\\\\\\\n    def action(self, colony):\\\\\\\\n        # BEGIN Problem 7\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Problem 7\\\\\\\\n\\\\\\\\nclass TankAnt(BodyguardAnt):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"TankAnt provides both offensive and defensive capabilities.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    name = \\\\\\\\'Tank\\\\\\\\'\\\\\\\\n    # BEGIN Problem 8\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\\\\\n    # END Problem 8\\\\\\\\n\\\\\\\\n    def action(self, colony):\\\\\\\\n        # BEGIN Problem 8\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Problem 8\\\\\\\\n\\\\\\\\n\\\\\\\\nclass QueenPlace(object):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"A place that represents both places in which the bees find the queen.\\\\\\\\n\\\\\\\\n    (1) The original colony queen location at the end of all tunnels, and\\\\\\\\n    (2) The place in which the QueenAnt resides.\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    def __init__(self, colony_queen, ant_queen):\\\\\\\\n        # BEGIN Problem 9\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Problem 9\\\\\\\\n\\\\\\\\n    @property\\\\\\\\n    def bees(self):\\\\\\\\n        # BEGIN Problem 9\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Problem 9\\\\\\\\n\\\\\\\\n\\\\\\\\nclass QueenAnt(Ant):  # You should change this line\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"The Queen of the colony.  The game is over if a bee enters her place.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    name = \\\\\\\\'Queen\\\\\\\\'\\\\\\\\n    # BEGIN Problem 9\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\\\\\n    # END Problem 9\\\\\\\\n\\\\\\\\n    def __init__(self):\\\\\\\\n        # BEGIN Problem 9\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Problem 9\\\\\\\\n\\\\\\\\n    def action(self, colony):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"A queen ant throws a leaf, but also doubles the damage of ants\\\\\\\\n        in her tunnel.\\\\\\\\n\\\\\\\\n        Impostor queens do only one thing: reduce their own armor to 0.\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        # BEGIN Problem 9\\\\\\\\n        \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n        # END Problem 9\\\\\\\\n\\\\\\\\n\\\\\\\\nclass AntRemover(Ant):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Allows the player to remove ants from the board in the GUI.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    name = \\\\\\\\'Remover\\\\\\\\'\\\\\\\\n    implemented = False\\\\\\\\n\\\\\\\\n    def __init__(self):\\\\\\\\n        Ant.__init__(self, 0)\\\\\\\\n\\\\\\\\n\\\\\\\\n##################\\\\\\\\n# Status Effects #\\\\\\\\n##################\\\\\\\\n\\\\\\\\ndef make_slow(action):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Return a new action method that calls action every other turn.\\\\\\\\n\\\\\\\\n    action -- An action method of some Bee\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    # BEGIN Problem EC\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    # END Problem EC\\\\\\\\n\\\\\\\\ndef make_stun(action):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Return a new action method that does nothing.\\\\\\\\n\\\\\\\\n    action -- An action method of some Bee\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    # BEGIN Problem EC\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    # END Problem EC\\\\\\\\n\\\\\\\\ndef apply_effect(effect, bee, duration):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Apply a status effect to a Bee that lasts for duration turns.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    # BEGIN Problem EC\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    # END Problem EC\\\\\\\\n\\\\\\\\n\\\\\\\\nclass SlowThrower(ThrowerAnt):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"ThrowerAnt that causes Slow on Bees.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    name = \\\\\\\\'Slow\\\\\\\\'\\\\\\\\n    # BEGIN Problem EC\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\\\\\n    # END Problem EC\\\\\\\\n\\\\\\\\n    def throw_at(self, target):\\\\\\\\n        if target:\\\\\\\\n            apply_effect(make_slow, target, 3)\\\\\\\\n\\\\\\\\n\\\\\\\\nclass StunThrower(ThrowerAnt):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"ThrowerAnt that causes Stun on Bees.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    name = \\\\\\\\'Stun\\\\\\\\'\\\\\\\\n    # BEGIN Problem EC\\\\\\\\n    \\\\\\\"*** REPLACE THIS LINE ***\\\\\\\"\\\\\\\\n    implemented = False   # Change to True when finished, to view in GUI\\\\\\\\n    # END Problem EC\\\\\\\\n\\\\\\\\n    def throw_at(self, target):\\\\\\\\n        if target:\\\\\\\\n            apply_effect(make_stun, target, 1)\\\\\\\\n\\\\\\\\n\\\\\\\\n##################\\\\\\\\n# Bees Extension #\\\\\\\\n##################\\\\\\\\n\\\\\\\\nclass Wasp(Bee):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Class of Bee that has higher damage.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    name = \\\\\\\\'Wasp\\\\\\\\'\\\\\\\\n    damage = 2\\\\\\\\n\\\\\\\\nclass Hornet(Bee):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Class of bee that is capable of taking two actions per turn, although\\\\\\\\n    its overall damage output is lower. Immune to status effects.\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    name = \\\\\\\\'Hornet\\\\\\\\'\\\\\\\\n    damage = 0.25\\\\\\\\n\\\\\\\\n    def action(self, colony):\\\\\\\\n        for i in range(2):\\\\\\\\n            if self.armor > 0:\\\\\\\\n                super().action(colony)\\\\\\\\n\\\\\\\\n    def __setattr__(self, name, value):\\\\\\\\n        if name != \\\\\\\\'action\\\\\\\\':\\\\\\\\n            object.__setattr__(self, name, value)\\\\\\\\n\\\\\\\\nclass NinjaBee(Bee):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"A Bee that cannot be blocked. Is capable of moving past all defenses to\\\\\\\\n    assassinate the Queen.\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    name = \\\\\\\\'NinjaBee\\\\\\\\'\\\\\\\\n\\\\\\\\n    def blocked(self):\\\\\\\\n        return False\\\\\\\\n            \\\\\\\\nclass Boss(Wasp, Hornet):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"The leader of the bees. Combines the high damage of the Wasp along with\\\\\\\\n    status effect immunity of Hornets. Damage to the boss is capped up to 8\\\\\\\\n    damage by a single attack.\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    name = \\\\\\\\'Boss\\\\\\\\'\\\\\\\\n    damage_cap = 8\\\\\\\\n    action = Wasp.action\\\\\\\\n\\\\\\\\n    def reduce_armor(self, amount):\\\\\\\\n        super().reduce_armor(self.damage_modifier(amount))\\\\\\\\n\\\\\\\\n    def damage_modifier(self, amount):\\\\\\\\n        return amount * self.damage_cap/(self.damage_cap + amount)\\\\\\\\n\\\\\\\\nclass Hive(Place):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"The Place from which the Bees launch their assault.\\\\\\\\n\\\\\\\\n    assault_plan -- An AssaultPlan; when & where bees enter the colony.\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    def __init__(self, assault_plan):\\\\\\\\n        self.name = \\\\\\\\'Hive\\\\\\\\'\\\\\\\\n        self.assault_plan = assault_plan\\\\\\\\n        self.bees = []\\\\\\\\n        for bee in assault_plan.all_bees:\\\\\\\\n            self.add_insect(bee)\\\\\\\\n        # The following attributes are always None for a Hive\\\\\\\\n        self.entrance = None\\\\\\\\n        self.ant = None\\\\\\\\n        self.exit = None\\\\\\\\n\\\\\\\\n    def strategy(self, colony):\\\\\\\\n        exits = [p for p in colony.places.values() if p.entrance is self]\\\\\\\\n        for bee in self.assault_plan.get(colony.time, []):\\\\\\\\n            bee.move_to(random.choice(exits))\\\\\\\\n            colony.active_bees.append(bee)\\\\\\\\n\\\\\\\\n\\\\\\\\nclass AntColony(object):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"An ant collective that manages global game state and simulates time.\\\\\\\\n\\\\\\\\n    Attributes:\\\\\\\\n    time -- elapsed time\\\\\\\\n    food -- the colony\\\\\\\\'s available food total\\\\\\\\n    queen -- the place where the queen resides\\\\\\\\n    places -- A list of all places in the colony (including a Hive)\\\\\\\\n    bee_entrances -- A list of places that bees can enter\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    def __init__(self, strategy, hive, ant_types, create_places, dimensions, food=2):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Create an AntColony for simulating a game.\\\\\\\\n\\\\\\\\n        Arguments:\\\\\\\\n        strategy -- a function to deploy ants to places\\\\\\\\n        hive -- a Hive full of bees\\\\\\\\n        ant_types -- a list of ant constructors\\\\\\\\n        create_places -- a function that creates the set of places\\\\\\\\n        dimensions -- a pair containing the dimensions of the game layout\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        self.time = 0\\\\\\\\n        self.food = food\\\\\\\\n        self.strategy = strategy\\\\\\\\n        self.hive = hive\\\\\\\\n        self.ant_types = OrderedDict((a.name, a) for a in ant_types)\\\\\\\\n        self.dimensions = dimensions\\\\\\\\n        self.active_bees = []\\\\\\\\n        self.configure(hive, create_places)\\\\\\\\n\\\\\\\\n    def configure(self, hive, create_places):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Configure the places in the colony.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        self.queen = Place(\\\\\\\\'AntQueen\\\\\\\\')\\\\\\\\n        self.places = OrderedDict()\\\\\\\\n        self.bee_entrances = []\\\\\\\\n        def register_place(place, is_bee_entrance):\\\\\\\\n            self.places[place.name] = place\\\\\\\\n            if is_bee_entrance:\\\\\\\\n                place.entrance = hive\\\\\\\\n                self.bee_entrances.append(place)\\\\\\\\n        register_place(self.hive, False)\\\\\\\\n        create_places(self.queen, register_place, self.dimensions[0], self.dimensions[1])\\\\\\\\n\\\\\\\\n    def simulate(self):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Simulate an attack on the ant colony (i.e., play the game).\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        num_bees = len(self.bees)\\\\\\\\n        while len(self.queen.bees) == 0 and num_bees > 0:\\\\\\\\n            self.hive.strategy(self)            # Bees invade\\\\\\\\n            self.strategy(self)                 # Ants deploy\\\\\\\\n            for ant in self.ants:               # Ants take actions\\\\\\\\n                if ant.armor > 0:\\\\\\\\n                    ant.action(self)\\\\\\\\n            for bee in self.active_bees[:]:     # Bees take actions\\\\\\\\n                if bee.armor > 0:\\\\\\\\n                    bee.action(self)\\\\\\\\n                if bee.armor <= 0:\\\\\\\\n                    num_bees -= 1\\\\\\\\n                    self.active_bees.remove(bee)\\\\\\\\n            self.time += 1\\\\\\\\n        if len(self.queen.bees) > 0:\\\\\\\\n            print(\\\\\\\\'The ant queen has perished. Please try again.\\\\\\\\')\\\\\\\\n            return False\\\\\\\\n        else:\\\\\\\\n            print(\\\\\\\\'All bees are vanquished. You win!\\\\\\\\')\\\\\\\\n            return True\\\\\\\\n\\\\\\\\n    def deploy_ant(self, place_name, ant_type_name):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Place an ant if enough food is available.\\\\\\\\n\\\\\\\\n        This method is called by the current strategy to deploy ants.\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        constructor = self.ant_types[ant_type_name]\\\\\\\\n        if self.food < constructor.food_cost:\\\\\\\\n            print(\\\\\\\\'Not enough food remains to place \\\\\\\\' + ant_type_name)\\\\\\\\n        else:\\\\\\\\n            ant = constructor()\\\\\\\\n            self.places[place_name].add_insect(ant)\\\\\\\\n            self.food -= constructor.food_cost\\\\\\\\n            return ant\\\\\\\\n\\\\\\\\n    def remove_ant(self, place_name):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Remove an Ant from the Colony.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        place = self.places[place_name]\\\\\\\\n        if place.ant is not None:\\\\\\\\n            place.remove_insect(place.ant)\\\\\\\\n\\\\\\\\n    @property\\\\\\\\n    def ants(self):\\\\\\\\n        return [p.ant for p in self.places.values() if p.ant is not None]\\\\\\\\n\\\\\\\\n    @property\\\\\\\\n    def bees(self):\\\\\\\\n        return [b for p in self.places.values() for b in p.bees]\\\\\\\\n\\\\\\\\n    @property\\\\\\\\n    def insects(self):\\\\\\\\n        return self.ants + self.bees\\\\\\\\n\\\\\\\\n    def __str__(self):\\\\\\\\n        status = \\\\\\\\' (Food: {0}, Time: {1})\\\\\\\\'.format(self.food, self.time)\\\\\\\\n        return str([str(i) for i in self.ants + self.bees]) + status\\\\\\\\n\\\\\\\\n\\\\\\\\ndef ant_types():\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Return a list of all implemented Ant classes.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    all_ant_types = []\\\\\\\\n    new_types = [Ant]\\\\\\\\n    while new_types:\\\\\\\\n        new_types = [t for c in new_types for t in c.__subclasses__()]\\\\\\\\n        all_ant_types.extend(new_types)\\\\\\\\n    return [t for t in all_ant_types if t.implemented]\\\\\\\\n\\\\\\\\ndef interactive_strategy(colony):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"A strategy that starts an interactive session and lets the user make\\\\\\\\n    changes to the colony.\\\\\\\\n\\\\\\\\n    For example, one might deploy a ThrowerAnt to the first tunnel by invoking\\\\\\\\n    colony.deploy_ant(\\\\\\\\'tunnel_0_0\\\\\\\\', \\\\\\\\'Thrower\\\\\\\\')\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    print(\\\\\\\\'colony: \\\\\\\\' + str(colony))\\\\\\\\n    msg = \\\\\\\\'<Control>-D (<Control>-Z <Enter> on Windows) completes a turn.\\\\\\\\\\\\\\\\n\\\\\\\\'\\\\\\\\n    interact(msg)\\\\\\\\n\\\\\\\\ndef start_with_strategy(args, strategy):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Reads command-line arguments and starts a game with those options.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    import argparse\\\\\\\\n    parser = argparse.ArgumentParser(description=\\\\\\\"Play Ants vs. SomeBees\\\\\\\")\\\\\\\\n    parser.add_argument(\\\\\\\\'-d\\\\\\\\', type=str, metavar=\\\\\\\\'DIFFICULTY\\\\\\\\',\\\\\\\\n                        help=\\\\\\\\'sets difficulty of game (easy/medium/hard/insane)\\\\\\\\')\\\\\\\\n    parser.add_argument(\\\\\\\\'-w\\\\\\\\', \\\\\\\\'--water\\\\\\\\', action=\\\\\\\\'store_true\\\\\\\\',\\\\\\\\n                        help=\\\\\\\\'loads a full layout with water\\\\\\\\')\\\\\\\\n    parser.add_argument(\\\\\\\\'--food\\\\\\\\', type=int,\\\\\\\\n                        help=\\\\\\\\'number of food to start with when testing\\\\\\\\', default=2)\\\\\\\\n    args = parser.parse_args()\\\\\\\\n\\\\\\\\n    assault_plan = make_test_assault_plan()\\\\\\\\n    layout = dry_layout\\\\\\\\n    tunnel_length = 9\\\\\\\\n    num_tunnels = 1\\\\\\\\n    food = args.food\\\\\\\\n\\\\\\\\n    if args.water:\\\\\\\\n        layout = wet_layout\\\\\\\\n    if args.d in [\\\\\\\\'e\\\\\\\\', \\\\\\\\'easy\\\\\\\\']:\\\\\\\\n        assault_plan = make_easy_assault_plan()\\\\\\\\n        num_tunnels = 2\\\\\\\\n        food = 2\\\\\\\\n    elif args.d in [\\\\\\\\'n\\\\\\\\', \\\\\\\\'normal\\\\\\\\']:\\\\\\\\n        assault_plan = make_normal_assault_plan()\\\\\\\\n        num_tunnels = 3\\\\\\\\n        food = 2\\\\\\\\n    elif args.d in [\\\\\\\\'h\\\\\\\\', \\\\\\\\'hard\\\\\\\\']:\\\\\\\\n        assault_plan = make_hard_assault_plan()\\\\\\\\n        num_tunnels = 4\\\\\\\\n        food = 2\\\\\\\\n    elif args.d in [\\\\\\\\'i\\\\\\\\', \\\\\\\\'insane\\\\\\\\']:\\\\\\\\n        assault_plan = make_insane_assault_plan()\\\\\\\\n        num_tunnels = 4\\\\\\\\n        food = 2\\\\\\\\n\\\\\\\\n    hive = Hive(assault_plan)\\\\\\\\n    dimensions = (num_tunnels, tunnel_length)\\\\\\\\n    return AntColony(strategy, hive, ant_types(), layout, dimensions, food).simulate()\\\\\\\\n\\\\\\\\n\\\\\\\\n###########\\\\\\\\n# Layouts #\\\\\\\\n###########\\\\\\\\n\\\\\\\\ndef wet_layout(queen, register_place, tunnels=3, length=9, moat_frequency=3):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Register a mix of wet and and dry places.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    for tunnel in range(tunnels):\\\\\\\\n        exit = queen\\\\\\\\n        for step in range(length):\\\\\\\\n            if moat_frequency != 0 and (step + 1) % moat_frequency == 0:\\\\\\\\n                exit = Water(\\\\\\\\'water_{0}_{1}\\\\\\\\'.format(tunnel, step), exit)\\\\\\\\n            else:\\\\\\\\n                exit = Place(\\\\\\\\'tunnel_{0}_{1}\\\\\\\\'.format(tunnel, step), exit)\\\\\\\\n            register_place(exit, step == length - 1)\\\\\\\\n\\\\\\\\ndef dry_layout(queen, register_place, tunnels=3, length=9):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Register dry tunnels.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n    wet_layout(queen, register_place, tunnels, length, 0)\\\\\\\\n\\\\\\\\n\\\\\\\\n#################\\\\\\\\n# Assault Plans #\\\\\\\\n#################\\\\\\\\n\\\\\\\\nclass AssaultPlan(dict):\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"The Bees\\\\\\\\' plan of attack for the Colony.  Attacks come in timed waves.\\\\\\\\n\\\\\\\\n    An AssaultPlan is a dictionary from times (int) to waves (list of Bees).\\\\\\\\n\\\\\\\\n    >>> AssaultPlan().add_wave(4, 2)\\\\\\\\n    {4: [Bee(3, None), Bee(3, None)]}\\\\\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n\\\\\\\\n    def add_wave(self, bee_type, bee_armor, time, count):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Add a wave at time with count Bees that have the specified armor.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        bees = [bee_type(bee_armor) for _ in range(count)]\\\\\\\\n        self.setdefault(time, []).extend(bees)\\\\\\\\n        return self\\\\\\\\n\\\\\\\\n    @property\\\\\\\\n    def all_bees(self):\\\\\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Place all Bees in the hive and return the list of Bees.\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\\n        return [bee for wave in self.values() for bee in wave]\\\\\\\\n\\\\\\\\ndef make_test_assault_plan():\\\\\\\\n    return AssaultPlan().add_wave(Bee, 3, 2, 1).add_wave(Bee, 3, 3, 1)\\\\\\\\n\\\\\\\\ndef make_easy_assault_plan():\\\\\\\\n    plan = AssaultPlan()\\\\\\\\n    for time in range(3, 16, 2):\\\\\\\\n        plan.add_wave(Bee, 3, time, 1)\\\\\\\\n    plan.add_wave(Wasp, 3, 4, 1)\\\\\\\\n    plan.add_wave(NinjaBee, 3, 8, 1)\\\\\\\\n    plan.add_wave(Hornet, 3, 12, 1)\\\\\\\\n    plan.add_wave(Boss, 15, 16, 1)\\\\\\\\n    return plan\\\\\\\\n\\\\\\\\ndef make_normal_assault_plan():\\\\\\\\n    plan = AssaultPlan()\\\\\\\\n    for time in range(3, 16, 2):\\\\\\\\n        plan.add_wave(Bee, 3, time, 2)\\\\\\\\n    plan.add_wave(Wasp, 3, 4, 1)\\\\\\\\n    plan.add_wave(NinjaBee, 3, 8, 1)\\\\\\\\n    plan.add_wave(Hornet, 3, 12, 1)\\\\\\\\n    plan.add_wave(Wasp, 3, 16, 1)\\\\\\\\n    \\\\\\\\n    #Boss Stage\\\\\\\\n    for time in range(21, 30, 2):\\\\\\\\n        plan.add_wave(Bee, 3, time, 2)\\\\\\\\n    plan.add_wave(Wasp, 3, 22, 2)\\\\\\\\n    plan.add_wave(Hornet, 3, 24, 2)\\\\\\\\n    plan.add_wave(NinjaBee, 3, 26, 2)\\\\\\\\n    plan.add_wave(Hornet, 3, 28, 2)\\\\\\\\n    plan.add_wave(Boss, 20, 30, 1)\\\\\\\\n    return plan\\\\\\\\n\\\\\\\\ndef make_hard_assault_plan():\\\\\\\\n    plan = AssaultPlan()\\\\\\\\n    for time in range(3, 16, 2):\\\\\\\\n        plan.add_wave(Bee, 4, time, 2)\\\\\\\\n    plan.add_wave(Hornet, 4, 4, 2)\\\\\\\\n    plan.add_wave(Wasp, 4, 8, 2)\\\\\\\\n    plan.add_wave(NinjaBee, 4, 12, 2)\\\\\\\\n    plan.add_wave(Wasp, 4, 16, 2)\\\\\\\\n    \\\\\\\\n    #Boss Stage\\\\\\\\n    for time in range(21, 30, 2):\\\\\\\\n        plan.add_wave(Bee, 4, time, 3)\\\\\\\\n    plan.add_wave(Wasp, 4, 22, 2)\\\\\\\\n    plan.add_wave(Hornet, 4, 24, 2)\\\\\\\\n    plan.add_wave(NinjaBee, 4, 26, 2)\\\\\\\\n    plan.add_wave(Hornet, 4, 28, 2)\\\\\\\\n    plan.add_wave(Boss, 30, 30, 1)\\\\\\\\n    return plan\\\\\\\\n\\\\\\\\ndef make_insane_assault_plan():\\\\\\\\n    plan = AssaultPlan()\\\\\\\\n    plan.add_wave(Hornet, 5, 2, 2)\\\\\\\\n    for time in range(3, 16, 2):\\\\\\\\n        plan.add_wave(Bee, 5, time, 2)\\\\\\\\n    plan.add_wave(Hornet, 5, 4, 2)\\\\\\\\n    plan.add_wave(Wasp, 5, 8, 2)\\\\\\\\n    plan.add_wave(NinjaBee, 5, 12, 2)\\\\\\\\n    plan.add_wave(Wasp, 5, 16, 2)\\\\\\\\n    \\\\\\\\n    #Boss Stage\\\\\\\\n    for time in range(21, 30, 2):\\\\\\\\n        plan.add_wave(Bee, 5, time, 3)\\\\\\\\n    plan.add_wave(Wasp, 5, 22, 2)\\\\\\\\n    plan.add_wave(Hornet, 5, 24, 2)\\\\\\\\n    plan.add_wave(NinjaBee, 5, 26, 2)\\\\\\\\n    plan.add_wave(Hornet, 5, 28, 2)\\\\\\\\n    plan.add_wave(Boss, 30, 30, 2)\\\\\\\\n    return plan\\\\\\\\n\\\\\\\\n\\\\\\\\nfrom utils import *\\\\\\\\n@main\\\\\\\\ndef run(*args):\\\\\\\\n    Insect.reduce_armor = class_method_wrapper(Insect.reduce_armor,\\\\\\\\n            pre=print_expired_insects)\\\\\\\\n    start_with_strategy(args, interactive_strategy)\\\\\\\\n'}\\\"\",\n        \"url\": \"http://www.cs61a.org/proj/ants\",\n        \"zip_file_url\": null\n    },\n    \"created\": \"2015-07-18 20:14:36.481730\",\n    \"id\": 6740807637794816,\n    \"invited\": [],\n    \"member\": [\n        {\n            \"created\": \"2015-06-21 20:11:09.502840\",\n            \"email\": [\n                \"binglinsong@berkeley.edu\"\n            ],\n            \"id\": 6682339753066496,\n            \"is_admin\": false\n        },\n        {\n            \"created\": \"2015-06-21 20:10:43.895930\",\n            \"email\": [\n                \"anthony0312@berkeley.edu\"\n            ],\n            \"id\": 5285489686872064,\n            \"is_admin\": false\n        }\n    ],\n    \"order\": null\n}"
        },
        "grading": {
            "Problem 0": {
                "failed": 0,
                "locked": 0,
                "passed": 6
            },
            "Problem 1": {
                "failed": 0,
                "locked": 0,
                "passed": 3
            },
            "Problem 2": {
                "failed": 0,
                "locked": 0,
                "passed": 3
            },
            "Problem 3A": {
                "failed": 0,
                "locked": 0,
                "passed": 8
            },
            "Problem 3B": {
                "failed": 0,
                "locked": 0,
                "passed": 6
            },
            "Problem 4A": {
                "failed": 0,
                "locked": 0,
                "passed": 6
            },
            "Problem 4B": {
                "failed": 0,
                "locked": 0,
                "passed": 11
            },
            "Problem 5A": {
                "failed": 0,
                "locked": 0,
                "passed": 2
            },
            "Problem 5B": {
                "failed": 0,
                "locked": 0,
                "passed": 5
            },
            "Problem 6A": {
                "failed": 0,
                "locked": 0,
                "passed": 7
            },
            "Problem 6B": {
                "failed": 0,
                "locked": 0,
                "passed": 5
            },
            "Problem 7": {
                "failed": 0,
                "locked": 0,
                "passed": 14
            },
            "Problem 8": {
                "failed": 0,
                "locked": 0,
                "passed": 7
            },
            "Problem 9": {
                "failed": 0,
                "locked": 0,
                "passed": 10
            },
            "Problem EC": {
                "failed": 0,
                "locked": 0,
                "passed": 6
            }
        }
    },
    "server_time": "2015-07-28 21:38:40.910400",
    "submitter": {
        "created": "2015-06-21 20:11:09.502840",
        "email": [
            "binglinsong@berkeley.edu"
        ],
        "id": 6682339753066496,
        "is_admin": false
    },
    "tags": []
}